
R version 4.2.1 (2022-06-23) -- "Funny-Looking Kid"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "iemisc"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('iemisc')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("AgivenF")
> ### * AgivenF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AgivenF
> ### Title: Annual value given Future value (Engineering Economics)
> ### Aliases: AgivenF AF
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example for equation 4-12 from the Reference text (page 135-136)
> AgivenF(309*10^6, 60, 0.5, "month")
[1] 368094.3
> 
> # the interest rate is 0.5% per month and n is 60 months
> # "$4.4187 million per month" is the answer
> 
> AF(309*10^6, 60, 0.5, "annual")
    n (periods) Annual Worth ($US)
 1:           0                 NA
 2:           1          309000000
 3:           2          154114713
 4:           3          102486712
 5:           4           76673033
 6:           5           61185082
 7:           6           50859996
 8:           7           43485117
 9:           8           37954119
10:           9           33652374
11:          10           30211107
12:          11           27395641
13:          12           25049527
14:          13           23064452
15:          14           21363051
16:          15           19888588
17:          16           18598514
18:          17           17460289
19:          18           16448605
20:          19           15543481
21:          20           14728934
22:          21           13992023
23:          22           13322163
24:          23           12710608
25:          24           12150069
26:          25           11634424
27:          26           11158493
28:          27           10717864
29:          28           10308755
30:          29            9927904
31:          30            9572486
32:          31            9240039
33:          32            8928411
34:          33            8635707
35:          34            8360260
36:          35            8100588
37:          36            7855379
38:          37            7623458
39:          38            7403778
40:          39            7195396
41:          40            6997465
42:          41            6809221
43:          42            6629971
44:          43            6459088
45:          44            6296001
46:          45            6140191
47:          46            5991184
48:          47            5848544
49:          48            5711874
50:          49            5580809
51:          50            5455011
52:          51            5334172
53:          52            5218005
54:          53            5106246
55:          54            4998650
56:          55            4894989
57:          56            4795054
58:          57            4698647
59:          58            4605587
60:          59            4515703
61:          60            4428836
    n (periods) Annual Worth ($US)
> # the interest rate is 0.5% per month and n is 60 months
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("AgivenFcont")
> ### * AgivenFcont
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AgivenFcont
> ### Title: Annual value given Future value [continuous] (Engineering
> ###   Economics)
> ### Aliases: AgivenFcont
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> AgivenFcont(300, 2, 11) # 11% interest
[1] 141.76
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("AgivenG")
> ### * AgivenG
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AgivenG
> ### Title: Annual value given Gradient value (Engineering Economics)
> ### Aliases: AgivenG
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 4-20 from the Reference text (pages 153-154)
>   AgivenG(1000, 4, 15, "annual") # the interest rate is 15%
[1] 1326.26
> 
> 
> # Example 4-31 from the Reference text (pages 166-167)
>   AgivenG(1000, 4, 20, "semiannual") # the nominal interest rate is 20% compounded semiannually
[1] 3004.48
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("AgivenP")
> ### * AgivenP
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AgivenP
> ### Title: Annual value given Present value (Engineering Economics)
> ### Aliases: AgivenP AP
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example for equation 4-14 from the Reference text (page 136)
> AgivenP(17000, 4, 1, "annual")
[1] 4356.78
> # the interest rate is 1% per month and n is 4 months
> 
> AP(17000, 4, 1, "annual")
   n (periods) Annual Worth ($US)
1:           0                 NA
2:           1           17170.00
3:           2            8627.71
4:           3            5780.38
5:           4            4356.78
> # the interest rate is 1% per month and n is 4 months
> 
> 
> # Example 4-30 from the Reference text (page 166)
> AgivenP(10000, 5, 12, "month")
[1] 222.44
> # the interest rate is 12% compounded monthly for 5 years
> 
> AP(10000, 5, 12, "month")
    n (periods) Annual Worth ($US)
 1:           0                 NA
 2:           1           10100.00
 3:           2            5075.12
 4:           3            3400.22
 5:           4            2562.81
 6:           5            2060.40
 7:           6            1725.48
 8:           7            1486.28
 9:           8            1306.90
10:           9            1167.40
11:          10            1055.82
12:          11             964.54
13:          12             888.49
14:          13             824.15
15:          14             769.01
16:          15             721.24
17:          16             679.45
18:          17             642.58
19:          18             609.82
20:          19             580.52
21:          20             554.15
22:          21             530.31
23:          22             508.64
24:          23             488.86
25:          24             470.73
26:          25             454.07
27:          26             438.69
28:          27             424.46
29:          28             411.24
30:          29             398.95
31:          30             387.48
32:          31             376.76
33:          32             366.71
34:          33             357.27
35:          34             348.40
36:          35             340.04
37:          36             332.14
38:          37             324.68
39:          38             317.61
40:          39             310.92
41:          40             304.56
42:          41             298.51
43:          42             292.76
44:          43             287.27
45:          44             282.04
46:          45             277.05
47:          46             272.28
48:          47             267.71
49:          48             263.34
50:          49             259.15
51:          50             255.13
52:          51             251.27
53:          52             247.56
54:          53             244.00
55:          54             240.57
56:          55             237.26
57:          56             234.08
58:          57             231.02
59:          58             228.06
60:          59             225.20
61:          60             222.44
    n (periods) Annual Worth ($US)
> # the interest rate is 12% compounded monthly for 5 years
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("AgivenPcont")
> ### * AgivenPcont
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: AgivenPcont
> ### Title: Annual value given Present value [continuous] (Engineering
> ###   Economics)
> ### Aliases: AgivenPcont
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example for equation 4-34 from the Reference text (page 170)
> AgivenPcont(1000, 10, 20) # 20% interest
[1] 256.06
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("CompIntCharg")
> ### * CompIntCharg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CompIntCharg
> ### Title: Compound Interest Charged (Engineering Economics)
> ### Aliases: CompIntCharg
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Compound Interest example from SFPE Reference text
> # Modified example to provide the compounded interest amount paid only
> 
> CompIntCharg(100, 5, 10, frequency = "annual") # the interest rate is 10%
[1] 61.05
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("CompIntPaid")
> ### * CompIntPaid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CompIntPaid
> ### Title: Compound Interest Paid (Engineering Economics)
> ### Aliases: CompIntPaid
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Compound Interest example from SFPE Reference text
> CompIntPaid(100, 5, 10, frequency = "annual") # the interest rate is 10%
[1] 161.05
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("EffInt")
> ### * EffInt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EffInt
> ### Title: Effective Interest rate (Engineering Economics)
> ### Aliases: EffInt
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 4-28 from Sullivan Reference text (page 165)
> EffInt(1.375, frequency = "month")
[1] 17.81
> # the nominal interest rate per period (month) is 1.375%
> 
> 
> # Example from SFPE Reference text
> EffInt(18 / 12, frequency = "month")
[1] 19.56
> # the nominal interest rate is 18% per year or 18% / 12 months
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("FgivenA")
> ### * FgivenA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FgivenA
> ### Title: Future value given Annual value (Engineering Economics)
> ### Aliases: FgivenA FA
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 4-7 from the Reference text (page 131-132)
> FgivenA(23000, 40, 6, "annual") # the interest rate is 6%
[1] 3559525
> 
> FA(23000, 40, 6, "annual") # the interest rate is 6%
    n (periods) Future Worth ($US)
 1:           0                 NA
 2:           1            23000.0
 3:           2            47380.0
 4:           3            73222.8
 5:           4           100616.2
 6:           5           129653.1
 7:           6           160432.3
 8:           7           193058.3
 9:           8           227641.8
10:           9           264300.3
11:          10           303158.3
12:          11           344347.8
13:          12           388008.7
14:          13           434289.2
15:          14           483346.5
16:          15           535347.3
17:          16           590468.2
18:          17           648896.2
19:          18           710830.0
20:          19           776479.8
21:          20           846068.6
22:          21           919832.7
23:          22           998022.7
24:          23          1080904.0
25:          24          1168758.3
26:          25          1261883.8
27:          26          1360596.8
28:          27          1465232.6
29:          28          1576146.6
30:          29          1693715.4
31:          30          1818338.3
32:          31          1950438.6
33:          32          2090464.9
34:          33          2238892.8
35:          34          2396226.4
36:          35          2562999.9
37:          36          2739779.9
38:          37          2927166.7
39:          38          3125796.7
40:          39          3336344.5
41:          40          3559525.2
    n (periods) Future Worth ($US)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("FgivenAcont")
> ### * FgivenAcont
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FgivenAcont
> ### Title: Future value given Annual value [continuous] (Engineering
> ###   Economics)
> ### Aliases: FgivenAcont
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> FgivenAcont(2100, 13, 7) # the interest rate is 7%
[1] 42989.32
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("FgivenP")
> ### * FgivenP
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FgivenP
> ### Title: Future value given Present value (Engineering Economics)
> ### Aliases: FgivenP FP
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 4-3 from the Reference text (page 124)
> FgivenP(8000, 4, 10, frequency = "annual") # the interest rate is 10%
[1] 11712.8
> 
> FP(8000, 4, 10, frequency = "annual") # the interest rate is 10%
   n (periods) Future Worth ($US)
1:           0             8000.0
2:           1             8800.0
3:           2             9680.0
4:           3            10648.0
5:           4            11712.8
> 
> 
> FgivenP(P = c(1000, 340, 23), n = c(12, 1.3, 3), i = c(10, 2, 0.3),
+ "annual")
[1] 3138.43  348.87   23.21
> # is is 10%, 2%, and 0.3%
> # Can't use FP for this example
> 
> 
> # Example 4-29 from the Reference text (page 165-166)
> FgivenP(100, 10, 6, "quarter") # the interest rate is 6% per quarter
[1] 181.4
> 
> FP(100, 10, 6, "quarter") # the interest rate is 6% per quarter
    n (periods) Future Worth ($US)
 1:           0             100.00
 2:           1             101.50
 3:           2             103.02
 4:           3             104.57
 5:           4             106.14
 6:           5             107.73
 7:           6             109.34
 8:           7             110.98
 9:           8             112.65
10:           9             114.34
11:          10             116.05
12:          11             117.79
13:          12             119.56
14:          13             121.36
15:          14             123.18
16:          15             125.02
17:          16             126.90
18:          17             128.80
19:          18             130.73
20:          19             132.70
21:          20             134.69
22:          21             136.71
23:          22             138.76
24:          23             140.84
25:          24             142.95
26:          25             145.09
27:          26             147.27
28:          27             149.48
29:          28             151.72
30:          29             154.00
31:          30             156.31
32:          31             158.65
33:          32             161.03
34:          33             163.45
35:          34             165.90
36:          35             168.39
37:          36             170.91
38:          37             173.48
39:          38             176.08
40:          39             178.72
41:          40             181.40
    n (periods) Future Worth ($US)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("FgivenPcont")
> ### * FgivenPcont
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FgivenPcont
> ### Title: Future value given Present value [continuous] (Engineering
> ###   Economics)
> ### Aliases: FgivenPcont
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 4-33 from the Reference text (page 170)
> FgivenPcont(10000, 2, 5) # the interest rate is 5%
[1] 11051.71
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("Manningpara")
> ### * Manningpara
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Manningpara
> ### Title: Parabolic cross-section for the Gauckler-Manning-Strickler
> ###   equation
> ### Aliases: Manningpara
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Exercise 4.3 from Sturm (page 153)
> y <- Manningpara(Q = 12.0, B1 = 10, y1 = 2.0, Sf = 0.005, n = 0.05, units = "SI")

Flow IS in the rough turbulent zone so the Gauckler-Manning-Strickler equation
 is acceptable to use.


This is subcritical flow.

> # defines all list values within the object named y
> # Q = 12.0 m^3/s, B1 = 10 m, y1 = 2.0 m, Sf = 0.005 m/m, n = 0.05, units = SI units
> # This will solve for y since it is missing and y will be in m
> 
> y$y # gives the value of y
[1] 1.254427
> 
> 
> 
> # Modified Exercise 4.3 from Sturm (page 153)
> Manningpara(y = y$y, B1 = 10, y1 = 2.0, Sf = 0.005, n = 0.05, units = "SI")

Flow IS in the rough turbulent zone so the Gauckler-Manning-Strickler equation
 is acceptable to use.


This is subcritical flow.

$Q
[1] 11.99949

$V
[1] 1.811761

$A
[1] 6.623108

$P
[1] 8.421472

$R
[1] 0.7864549

$B
[1] 7.919681

$D
[1] 0.8362847

$Re
[1] 1419294

$Fr
[1] 0.63265

> # y = 1.254427 m, B1 = 10 m, y1 = 2.0 m, Sf = 0.005 m/m, n = 0.05, units = SI units
> # This will solve for Q since it is missing and Q will be in m^3/s
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("Manningtrap")
> ### * Manningtrap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Manningtrap
> ### Title: Trapezoidal cross-section for the Gauckler-Manning-Strickler
> ###   equation
> ### Aliases: Manningtrap
> 
> ### ** Examples
> 
> 
> # Example 1
> 
> library(iemisc)
> # Exercise 4.1 from Sturm (page 153)
> 
> uu <- Manningtrap(Q = 3000, b = 40, m = 3, Sf = 0.002, n = 0.025,
+ units = "Eng", type = "symmetrical", output = "list")

Flow IS in the rough turbulent zone so the Gauckler-Manning-Strickler equation
 is acceptable to use.


This is subcritical flow.

> # Q = 3000 cfs, b = 40 ft, m = 3, Sf = 0.002 ft/ft, n = 0.025,
> # units = English units
> # This will solve for y since it is missing and y will be in ft
> 
> uu$y # only returns y
[1] 6.603559
> 
> uu # returns all results
$y
[1] 6.603559

$Q
[1] 3000

$V
[1] 7.595642

$b
[1] 40

$m
[1] 3

$Sf
[1] 0.002

$n
[1] 0.025

$A
[1] 394.9633

$P
[1] 81.76457

$R
[1] 4.830495

$B
[1] 79.62135

$D
[1] 4.96052

$w
[1] 20.88229

$Z
[1] 1128.629

$E
[1] 7.500149

$K
[1] 67082.03

$Vel_Head
[1] 0.8965905

$Re
[1] 3395342

$Fr
[1] 0.6012408

$taud
[1] 0.8229747

$tau0
[1] 0.6020049

> 
> 
> 
> # Example 2
> 
> # Please refer to the iemisc: Manning... Examples using iemiscdata
> # [https://www.ecoccs.com/R_Examples/Manning_iemiscdata_Examples.pdf] and iemisc:
> # Open Channel Flow Examples involving Geometric Shapes with the
> # Gauckler-Manning-Strickler Equation
> # [https://www.ecoccs.com/R_Examples/Open-Channel-Flow_Examples_Geometric_Shapes.pdf]
> # for the cross-section examples using iemiscdata
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("Manningtrap_critical")
> ### * Manningtrap_critical
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Manningtrap_critical
> ### Title: Trapezoidal cross-section for the Gauckler-Manning-Strickler
> ###   equation (critical parameters)
> ### Aliases: Manningtrap_critical
> 
> ### ** Examples
> 
> 
> # Example 1
> 
> library(iemisc)
> # Exercise 4.1 from Sturm (page 153)
> 
> uuc <- Manningtrap_critical(Q = 3000, b = 40, m = 3, Sf = 0.002, n = 0.025,
+ units = "Eng", type = "symmetrical", critical = "accurate", output = "list")

Flow IS in the rough turbulent zone so the Gauckler-Manning-Strickler equation
 is acceptable to use.


This is subcritical flow.

> # Q = 3000 cfs, b = 40 ft, m = 3, Sf = 0.002 ft/ft, n = 0.025,
> # units = English units
> # This will solve for y since it is missing and y will be in ft
> 
> uuc$y # only returns y
[1] 6.603559
> 
> uuc # returns all results
$y
[1] 6.603559

$Q
[1] 3000

$V
[1] 7.596

$b
[1] 40

$m
[1] 3

$Sf
[1] 0.002

$n
[1] 0.025

$A
[1] 394.963

$P
[1] 81.765

$R
[1] 4.83

$B
[1] 79.621

$D
[1] 4.961

$w
[1] 20.882

$Z
[1] 1128.629

$E
[1] 7.5

$K
[1] 67082.03

$Vel_Head
[1] 0.897

$Re
[1] 3395342

$Fr
[1] 0.601

$taud
[1] 0.823

$tau0
[1] 0.602

$yc
[1] 5.591

$Ac
[1] 317.427

$Pc
[1] 75.361

$Bc
[1] 73.547

$Rc
[1] 4.212

$Dc
[1] 4.316

$Vc
[1] 13.412

$Qc
[1] 4989.681

$Sfc
[1] 0.00373

$Frc
[1] 1

$Zc
[1] 879.671

$Ec
[1] 6.979

> 
> 
> 
> # Example 2
> 
> # Please refer to the iemisc: Manning... Examples using iemiscdata
> # [https://www.ecoccs.com/R_Examples/Manning_iemiscdata_Examples.pdf] and iemisc:
> # Open Channel Flow Examples involving Geometric Shapes with the
> # Gauckler-Manning-Strickler Equation
> # [https://www.ecoccs.com/R_Examples/Open-Channel-Flow_Examples_Geometric_Shapes.pdf]
> # for the cross-section examples using iemiscdata
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("Manningtri")
> ### * Manningtri
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Manningtri
> ### Title: Triangular cross-section for the Gauckler-Manning-Strickler
> ###   equation
> ### Aliases: Manningtri
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Manning... Examples using iemiscdata
> # [https://www.ecoccs.com/R_Examples/Manning_iemiscdata_Examples.pdf] and iemisc:
> # Open Channel Flow Examples involving Geometric Shapes with the
> # Gauckler-Manning-Strickler Equation
> # [https://www.ecoccs.com/R_Examples/Open-Channel-Flow_Examples_Geometric_Shapes.pdf]
> # for the cross-section examples using iemiscdata
> 
> 
> 
> library(iemisc)
> 
> # Modified Exercise 4.1 from Sturm (page 153)
> Manningtri(Q = 3000, m = 3, Sf = 0.002, n = 0.025, units = "Eng")

Flow IS in the rough turbulent zone so the Gauckler-Manning-Strickler equation
 is acceptable to use.


This is subcritical flow.

$y
[1] 11.13688

$V
[1] 8.062556

$A
[1] 372.0905

$P
[1] 70.43583

$R
[1] 5.282687

$B
[1] 66.8213

$D
[1] 5.568441

$Re
[1] 3941442

$Fr
[1] 0.6023563

> # Q = 3000 cfs, m = 3, Sf = 0.002 ft/ft, n = 0.025, units = English units
> # This will solve for y since it is missing and y will be in ft
> 
> 
> 
> # Modified Exercise 4.5 from Sturm (page 154)
> Manningtri(Q = 950, m = 2, Sf = 0.022, n = 0.023, units = "SI")

Flow IS in the rough turbulent zone so the Gauckler-Manning-Strickler equation
 is acceptable to use.


This is supercritical flow.

$y
[1] 6.131617

$V
[1] 12.63408

$A
[1] 75.19345

$P
[1] 27.42142

$R
[1] 2.742142

$B
[1] 24.52647

$D
[1] 3.065809

$Re
[1] 34508903

$Fr
[1] 2.30415

> # Q = 950 m^3/s, m = 2, Sf = 0.022 m/m, n = 0.023, units = SI units
> # This will solve for y since it is missing and y will be in m
> 
> 
> 
> 
> cleanEx()
> nameEx("Mod_octave")
> ### * Mod_octave
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Mod_octave
> ### Title: Modulus Operation (GNU Octave/MATLAB compatible)
> ### Aliases: Mod_octave
> 
> ### ** Examples
> 
> 
> # Example from FreeMat
> 
> library(iemisc)
> 
> Mod_octave(18, 12)
[1] 6
> 
> # Please refer to the iemisc: Examples from GNU Octave Rem, Mod, and
> # fractdiff Compatible Functions vignette for additional examples
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("PgivenA")
> ### * PgivenA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PgivenA
> ### Title: Present value given Annual value (Engineering Economics)
> ### Aliases: PgivenA PA
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 1 -- Example 4-9 from the Sullivan Reference text (page 133-134)
> PgivenA(A = 20000, n = 5, i = 15, frequency = "annual") # the interest rate is 15%
[1] 67043.1
> 
> PA(20000, 5, 15, "annual") # the interest rate is 15%
   n (periods) Present Worth ($US)
1:           0                  NA
2:           1            17391.30
3:           2            32514.18
4:           3            45664.50
5:           4            57099.57
6:           5            67043.10
> 
> 
> # Example 2
> 
> PgivenA(A = 93.22, n = 5, i = 4.50, frequency = "month")
[1] 5000.26
> 
> # Using LibreOffice Calc 6.1.5.2 version
> # A1 4.50%
> # A2 -93.22
> # A3 60
> # A4 12
> # A5 =PV(A1/A4,A3,A2) = $5,000.26
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("PgivenA1")
> ### * PgivenA1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PgivenA1
> ### Title: Present value for geometric gradient series (Engineering
> ###   Economics)
> ### Aliases: PgivenA1
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 4-23 from the Reference text (page 158-159)
> PgivenA1(A1 = 1000, i = 25, f = 20, n = 4) # i is 25% and f is 20%
[1] 3013.07
> 
> 
> # Example 4-24 from the Reference text (page 159)
> PgivenA1(A1 = 1000, i = 25, f = -20, n = 4) # i is 25% and f is -20%
[1] 1849.4
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("PgivenAcont")
> ### * PgivenAcont
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PgivenAcont
> ### Title: Present value given Annual value [continuous] (Engineering
> ###   Economics)
> ### Aliases: PgivenAcont
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> PgivenAcont(2000, 3, 12) # the interest rate is 12%
[1] 4742.45
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("PgivenF")
> ### * PgivenF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PgivenF
> ### Title: Present value given Future value (Engineering Economics)
> ### Aliases: PgivenF PF
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 4-4 from the Reference text (page 128)
> PgivenF(10000, 6, 8, "annual") # the interest rate is 8%
[1] 6301.7
> 
> PF(10000, 6, 8, "annual") # the interest rate is 8%
   n (periods) Present Worth ($US)
1:           0            10000.00
2:           1             9259.26
3:           2             8573.39
4:           3             7938.32
5:           4             7350.30
6:           5             6805.83
7:           6             6301.70
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("PgivenFcont")
> ### * PgivenFcont
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PgivenFcont
> ### Title: Present value given Future value [continuous] (Engineering
> ###   Economics)
> ### Aliases: PgivenFcont
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> PgivenFcont(1000, 9, 7) # the interest rate is 7%
[1] 532.59
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("PgivenFivary")
> ### * PgivenFivary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PgivenFivary
> ### Title: "Present equivalent of a series of future cash flows subject to
> ###   varying interest rates" (Engineering Economics)
> ### Aliases: PgivenFivary
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example for equation 4-31 from the Reference text (page 162)
> PgivenFivary(Fn = 1000, ik = c(10, 12, 13, 10), k = 1)
[1] 653.01
> # i1 is 10%, i2 is 12%, i3 is 14%, and i4 is 10% & k = 1 year
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("PgivenG")
> ### * PgivenG
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PgivenG
> ### Title: Present value given Gradient value (Engineering Economics)
> ### Aliases: PgivenG
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 4-20 from the Reference text (pages 153-154)
> PgivenG(1000, 4, 15, "annual") # the interest rate is 15%
[1] 3786.44
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("Re1")
> ### * Re1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Re1
> ### Title: Calculating the Reynolds Number 1
> ### Aliases: Re1
> 
> ### ** Examples
> 
> 
> # from Lindeburg Reference page 17-8
> # D = 0.3355 ft
> # V = 7.56 ft/sec
> 
> # from the Chow reference, water at 68 F (20 C) has the following properties
> 
> library(iemisc)
> 
> # mu (dynamic viscosity) = 2.09 * 10 ^ -5 slug/ft-sec
> # rho (density) = 1.937 slug/ft^3
> # v (kinematic viscosity) = mu / rho = 1.08 * 10 ^ -5
> 
> Re1(D = 0.3355, V = 7.56, rho = 1.937, mu = 2.09 * 10 ^ -5, units = "slug")
$nu
[1] 1.078988e-05

$Re1
[1] 235070.2

> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("Re2")
> ### * Re2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Re2
> ### Title: Calculating the Reynolds Number 2
> ### Aliases: Re2
> 
> ### ** Examples
> 
> 
> # from Lindeburg Reference page 17-8
> # where
> # D = 0.3355 ft
> # V = 7.56 ft/sec
> # nu = 1.41 * 10 ^ -5 ft^2 / sec
> # and
> # Re = 1.8 * 10 ^ 5
> 
> library(iemisc)
> 
> Re2(D = 0.3355, V = 7.56, nu = 1.41 * 10 ^ -5)
[1] 179885.1
> 
> # compare to Re1(D = 0.3355, V = 7.56, rho = 1.937, mu = 2.09 * 10 ^ -5, units = "slug")
> 
> Re2(D = 0.3355, V = 7.56, nu = 1.08 * 10 ^ -5)
[1] 234850
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("Re4")
> ### * Re4
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Re4
> ### Title: Calculating the Reynolds Number 4
> ### Aliases: Re4
> 
> ### ** Examples
> 
> 
> # part of Example 3 from Subramanian Pipe Flow Calculations
> 
> # Q = 2.23 * 10 ^ - 2 ft^3/s
> # nu = 2.40 * 10 ^ -5 ft^2/s
> # D = 9.03 * 10 ^ -2 ft
> 
> library(iemisc)
> 
> Re4(Q = 2.23 * 10 ^ -2, nu = 2.40 * 10 ^ -5, D = 9.03 * 10 ^ -2)
[1] 13101.35
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("Rem")
> ### * Rem
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rem
> ### Title: Remainder After Division (GNU Octave/MATLAB compatible)
> ### Aliases: Rem
> 
> ### ** Examples
> 
> 
> # Example from GNU Octave
> 
> library(iemisc)
> 
> x <- 23.4
> y <- 20
> 
> Rem(x, y)
[1] 3.4
> 
> 
> # Please refer to the iemisc: Examples from GNU Octave Rem, Mod, and
> # fractdiff Compatible Functions vignette for additional examples
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("SimpIntCharg")
> ### * SimpIntCharg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SimpIntCharg
> ### Title: Simple Interest Charged (Engineering Economics)
> ### Aliases: SimpIntCharg
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example for equation 4-1 from the Sullivan Reference text (page 116)
> # Modified example to provide the simple interest amount paid only
> 
> SimpIntCharg(P = 1000, n = 3, i = 10) # the interest rate is 10%
[1] 300
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("SimpIntPaid")
> ### * SimpIntPaid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SimpIntPaid
> ### Title: Simple Interest Paid (Engineering Economics)
> ### Aliases: SimpIntPaid
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example for equation 4-1 from the Sullivan Reference text (page 116)
> SimpIntPaid(1000, 3, 10) # the interest rate is 10%
[1] 1300
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("acosd")
> ### * acosd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: acosd
> ### Title: Inverse cosine (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: acosd
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave acosd
> acosd (seq(0, 1, by = 0.1))
 [1] 90.00000 84.26083 78.46304 72.54240 66.42182 60.00000 53.13010 45.57300
 [9] 36.86990 25.84193  0.00000
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("acotd")
> ### * acotd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: acotd
> ### Title: Inverse cotangent (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: acotd
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave acotd
> acotd (seq(10, 90, by = 10))
[1] 5.7105931 2.8624052 1.9091524 1.4320962 1.1457628 0.9548413 0.8184555
[8] 0.7161599 0.6365936
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("acscd")
> ### * acscd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: acscd
> ### Title: Inverse cosecant (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: acscd
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave acscd
> acscd (seq(0, 90, by = 10))
Warning in asin(1/z) : NaNs produced
 [1]       NaN 5.7391705 2.8659840 1.9102132 1.4325437 1.1459920 0.9549739
 [8] 0.8185390 0.7162159 0.6366329
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("approxerror")
> ### * approxerror
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: approxerror
> ### Title: Approximate error
> ### Aliases: approxerror
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 4.1 from the Reference text (page 84)
> 
> approxerror(1.5, 1) # answer as a percent (%)
[1] 33.33333
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("asecd")
> ### * asecd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asecd
> ### Title: Inverse secant (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: asecd
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave asecd
> asecd (seq(0, 90, by = 10))
Warning in acos(1/z) : NaNs produced
 [1]      NaN 84.26083 87.13402 88.08979 88.56746 88.85401 89.04503 89.18146
 [9] 89.28378 89.36337
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("asind")
> ### * asind
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asind
> ### Title: Inverse sine (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: asind
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave asind
> asind(seq(0, 1, by = 0.1))
 [1]  0.00000  5.73917 11.53696 17.45760 23.57818 30.00000 36.86990 44.42700
 [9] 53.13010 64.15807 90.00000
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("atan2d")
> ### * atan2d
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: atan2d
> ### Title: "Two-argument arc-tangent" (in degrees) [GNU Octave/MATLAB
> ###   compatible]
> ### Aliases: atan2d
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave atan2d
> atan2d (a <- seq(-1, 1, by = 0.1), b <- seq(1, -1, by = -0.1))
 [1] -45 -45 -45 -45 -45 -45 -45 -45 -45 -45   0 135 135 135 135 135 135 135 135
[20] 135 135
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("atand")
> ### * atand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: atand
> ### Title: Inverse tangent (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: atand
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave atand
> atand (seq(0, 90, by = 10))
 [1]  0.00000 84.28941 87.13759 88.09085 88.56790 88.85424 89.04516 89.18154
 [9] 89.28384 89.36341
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("benefitcost")
> ### * benefitcost
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: benefitcost
> ### Title: Benefit-Cost Ratio (Engineering Economics)
> ### Aliases: benefitcost
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example from Lindeburg Reference text (page 14-4)
> benefitcost(ic1 = 300000, n1 = 10, ac1 = 45000, ab1 = 150000, i1 = 10,
+ salvage1 = 0, ic2 = 400000, n2 = 10, ac2 = 35000, ab2 = 200000, i2 = 10,
+ salvage2 = 10000, option1 = "A", option2 = "B", table = "rtable")

 The Benefit-Cost ratio of B to A is 8.85 thus choose B. 

                   V1        A          B
1:            Benefit 921685.1 1228913.42
2:               Cost 576505.5  611204.42
3: Benefit-Cost Ratio      1.6       2.01
> 
> 
> # This is useful for saving the results as the named data.frame rtable
> rtable <- benefitcost(ic1 = 300000, n1 = 10, ac1 = 45000, ab1 = 150000,
+ i1 = 10, salvage1 = 0, ic2 = 400000, n2 = 10, ac2 = 35000, ab2 = 200000,
+ i2 = 10, salvage2 = 10000, option1 = "A", option2 = "B", table = "rtable")

 The Benefit-Cost ratio of B to A is 8.85 thus choose B. 

> 
> rtable
                   V1        A          B
1:            Benefit 921685.1 1228913.42
2:               Cost 576505.5  611204.42
3: Benefit-Cost Ratio      1.6       2.01
> 
> 
> 
> # This is useful for saving the results as the named data.frame ptable
> ptable <- benefitcost(ic1 = 300000, n1 = 10, ac1 = 45000, ab1 = 150000,
+ i1 = 10, salvage1 = 0, ic2 = 400000, n2 = 10, ac2 = 35000, ab2 = 200000,
+ i2 = 10, salvage2 = 10000, option1 = "A", option2 = "B", table = "ptable")

 The Benefit-Cost ratio of B to A is 8.85 thus choose B. 

> 
> ptable
                   V1          A            B
1:            Benefit 921,685.07 1,228,913.42
2:               Cost 576,505.52   611,204.42
3: Benefit-Cost Ratio        1.6         2.01
> 
> 
> 
> # This is useful for saving the results as the named list of 2 data.frames
> # called both
> both <- benefitcost(ic1 = 300000, n1 = 10, ac1 = 45000, ab1 = 150000,
+ i1 = 10, salvage1 = 0, ic2 = 400000, n2 = 10, ac2 = 35000, ab2 = 200000,
+ i2 = 10, salvage2 = 10000, option1 = "A", option2 = "B", table = "both")

 The Benefit-Cost ratio of B to A is 8.85 thus choose B. 

> 
> both
[[1]]
                   V1        A          B
1:            Benefit 921685.1 1228913.42
2:               Cost 576505.5  611204.42
3: Benefit-Cost Ratio      1.6       2.01

[[2]]
                   V1          A            B
1:            Benefit 921,685.07 1,228,913.42
2:               Cost 576,505.52   611,204.42
3: Benefit-Cost Ratio        1.6         2.01

> 
> 
> 
> # Example 10-8 from the Sullivan Reference text (page 452-453)
> project <- benefitcost(ic1 = 750000, n1 = 35, ac1 = 120000, ab1 = 245000,
+ i1 = 9, salvage1 = 0, ic2 = 625000, n2 = 25, ac2 = 110000, ab2 = 230000,
+ i2 = 9, salvage2 = 0, option1 = "Project I", option2 = "Project II",
+ table = "rtable")

 The Benefit-Cost ratio of Project II to Project I is 1.05 thus choose Project II. 

> 
> project
                   V1  Project I Project II
1:            Benefit 2588871.26 2259193.31
2:               Cost 2018018.58 1705483.76
3: Benefit-Cost Ratio       1.28       1.32
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("colebrook")
> ### * colebrook
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colebrook
> ### Title: Accurately calculate the Colebrook-White equation to obtain the
> ###   Darcy-Weisbach friction factor
> ### Aliases: colebrook
> 
> ### ** Examples
> 
> 
> install.load::load_package("iemisc", "units")
udunits database from /Users/emaurer/Documents/classes/R_package_dev/hydraulics/revdep/library.noindex/iemisc/units/share/udunits/udunits2.xml
> 
> # Example 1 (Reference: Clamond)
> F <- colebrook(c(3e3, 7e5, 1e100), 0.01)
> 
> F
[1] 4.351919e-02 1.238992e-02 2.640067e-05
> 
> 
> # Example 2
> # 'Determine f for air flow through a smooth, thin tube. The parameters are
> # rho = 1.23 kg/m^3, mu = 1.79 x 10^-5 N * s/m^2, D = 0.005 m, V = 40 m/s
> # and epsilon = 0.0015 mm.' Reference: Chapra 158
> 
> # Determine R (the Reynolds number) first using the following parameters:
> 
> rho <- 1.23 # kg/m^3
> V <- 40 # m/s
> D <- 0.005 # m
> mu <- 1.79 * 10^-5 # N * s/m^2
> 
> eps <- 0.0015 # mm
> eps <- set_units(eps, "mm")
> units(eps) <- make_units(m)
> 
> Re <- rho * V * D / mu
> 
> 
> K <- drop_units(eps) / D
> 
> 
> # with K
> fr1 <- colebrook(Re, K); fr1
[1] 0.02843153
> 
> # without K
> fr2 <- colebrook(Re); fr2
[1] 0.02843153
> 
> 
> # The solution on Chapra 159 and 160 is 'f = 0.02896781017144' which was
> # computed using the Newton-Raphson method, Swamee-Jain approximation
> # equation, and MATLAB's fzero function.
> 
> # Thus,
> fm <- 0.02896781017144
> 
> # Compute the relative error between fr[1 and 2] (this function) and fm (Chapra).
> 
> relerror(fr1, fm)
[1] 1.886212
> 
> 
> relerror(fr2, fm)
[1] 1.886212
> 
> # compare the relative error with and without K
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:units’

> nameEx("concr_mix_lightweight_strength")
> ### * concr_mix_lightweight_strength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: concr_mix_lightweight_strength
> ### Title: Concrete Mix Design for Structural Lightweight Concrete
> ### Aliases: concr_mix_lightweight_strength
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example A from Section 3.2.3 using the 'Weight method (specific gravity
> # pycnometers)' from ACI Committee 211
> # Design a concrete mix for 3500 psi concrete strength, 'floor slab of a
> # multistory structure subjected to freezing and thawing during
> # construction', and a maximum size of aggregate = 3/4 in, with Fineness
> # Modulus of sand = 2.80, 'the oven-dry loose weight of coarse aggregate' =
> # 47 lb/ft^3 with a specific gravity factor = 1.50, and a absorption of
> # 11.0% for the coarse aggregate and 1.0% for the fine aggregate.
> 
> concr_mix_lightweight_strength(fc = 3500, max_size_aggr = 3 / 4, FM = 2.80,
+ sgf_coarse = 1.50, dry_rod_wt_aggr = 47, absorp_coarse = 11.0,
+ absorp_fine = 1.0, entrainment = "Air", construction_type = "Floor slabs",
+ slump_value = "Maximum", exposure = "Extreme", structure_type = "Other",
+ severe_exposure = "Wet", trial_batch = "1 cubic foot")
Warning in interp1(wc1, c(0, wc3), xi = fc, method = "linear") :
  Points in argument in 'x' unsorted; will be sorted.
$cement
[1] 22.59

$sand
[1] 39.96

$gravel
[1] 36.52

$water
[1] 11.3

> 
> 
> 
> 
> 
> cleanEx()
> nameEx("concr_mix_normal_strength")
> ### * concr_mix_normal_strength
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: concr_mix_normal_strength
> ### Title: Concrete Mix Design for Normal Strength (Normal-weight) Concrete
> ### Aliases: concr_mix_normal_strength
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # 'Example 3.1 Mixture Design of Normal-weight Concrete' from Nawy
> # (page 23-28)
> # Design a concrete mix for 4000 psi concrete strength, beam, and a maximum
> # size of aggregate = 3/4 in, with Fineness Modulus of sand = 2.6, the dry
> # rodded weight of aggregate = 100 lb/ft^3^, and a moisture content of 3%
> # for the coarse aggregate and 2% for the fine aggregate.
> 
> concr_mix_normal_strength(fc = 4000, max_size_aggr = 3 / 4, FM = 2.6,
+ dry_rod_wt_aggr = 100, mc_coarse = 3, mc_fine = 2, entrainment = "Nonair",
+ construction_type = "Reinforced Foundation walls and footings", slump_value
+ = "Maximum", exposure = "Nonair", trial_batch = "1 cubic yard")
Warning in interp1(wc1, wc2, xi = fc, method = "linear") :
  Points in argument in 'x' unsorted; will be sorted.
$cement
[1] 596.49

$sand
[1] 1321.42

$gravel
[1] 1779.84

$water
[1] 262.25

> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("construction_decimal")
> ### * construction_decimal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: construction_decimal
> ### Title: Construction Decimal
> ### Aliases: construction_decimal
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Construction Measurement Examples vignette for
> # additional examples
> 
> # Example 1
> 
> library(iemisc)
> 
> construction_decimal("2'-0\"", result = "traditional", output = "vector")
[1] 2
> 
> construction_decimal("1'-2 7/16\"", result = "librecad", output = "vector")
[1] 14.4375
> 
> 
> 
> # Example 2
> 
> library(iemisc)
> 
> construction_decimal("0 6", result = "traditional", output = "vector")
[1] 0.5
> 
> construction_decimal("0 6", result = "librecad", output = "vector")
[1] 6
> 
> 
> 
> # Example 3
> 
> library(iemisc)
> 
> tss1 <- "48'-0 1/2\""
> tss2 <- "56-9 1/2\""
> 
> sum(construction_decimal(tss1, result = "traditional", output = "vector"),
+ construction_decimal(tss2, result = "traditional", output = "vector"))
[1] 104.8333
> 
> 
> 
> 
> 
> # Example 5
> 
> library(iemisc)
> 
> app1 <- "5' 2\""
> 
> app2 <- "6' 3\""
> 
> app3 <- construction_decimal(app1, result = "traditional", output = "vector") *
+ construction_decimal(app2, result = "traditional", output = "vector")
> app3
[1] 32.29167
> 
> # If you want to have the fractional value using 16ths, do the following:
> 
> construction_fraction(app3, type = "traditional", result = "traditional",
+ fraction = 16)
[1] "32 ft 3 8/16 in"
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("construction_decimal_eng")
> ### * construction_decimal_eng
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: construction_decimal_eng
> ### Title: Construction Decimal Engineering (LibreCAD Style)
> ### Aliases: construction_decimal_eng
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Construction Measurement Examples vignette for
> # additional examples
> 
> library(iemisc)
> 
> librecad1a <- "1 ft 2 7/16\""
> 
> construction_decimal_eng(librecad1a)
[1] "1'-2.4375\""
> 
> 
> librecad4a <- 14.43112
> 
> construction_decimal_eng(librecad4a)
[1] "1'-2.43112\""
> 
> 
> librecad5a <- 14.4375
> 
> construction_decimal_eng(librecad5a)
[1] "1'-2.4375\""
> 
> 
> librecad6a <- 17.71354
> 
> construction_decimal_eng(librecad6a)
[1] "1'-5.71354\""
> 
> 
> librecad7a <- 86.000000
> 
> construction_decimal_eng(librecad7a)
[1] "7'-2\""
> 
> 
> checkst <- 14.43112
> 
> construction_decimal_eng(checkst)
[1] "1'-2.43112\""
> 
> construction_fraction(checkst, type = "librecad", result = "traditional",
+ fraction = 16)
[1] "1 ft 2 7/16 in"
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("construction_fraction")
> ### * construction_fraction
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: construction_fraction
> ### Title: Construction Fraction
> ### Aliases: construction_fraction
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Construction Measurement Examples vignette for
> # additional examples
> 
> library(iemisc)
> 
> # Example 1 from the Spike Reference
> 
> check1 <- 18.649 # decimal feet
> 
> construction_fraction(check1, type = "traditional", result =
+ "traditional", fraction = 16)
[1] "18 ft 7 13/16 in"
> 
> # Reverse the calculation to check out the absolute error
> 
> check2 <- construction_decimal(construction_fraction(check1,
+ type = "traditional", result = "traditional", fraction = 16),
+ result = "traditional", output = "vector")
> 
> fracture::fracture(check2 - check1) # difference in inches
[1] 49/24000
> 
> # by approximate error
> 
> approxerror(check2, check1) # answer as a percent (%)
[1] 0.01094666
> 
> 
> # check all other fraction levels
> 
> construction_fraction(check1, type = "traditional", result =
+ "traditional", fraction = 0)
[1] "18 ft 7 in"
> 
> construction_fraction(check1, type = "traditional", result =
+ "traditional", fraction = 2)
[1] "18 ft 7 2/2 in"
> 
> construction_fraction(check1, type = "traditional", result =
+ "traditional", fraction = 4)
[1] "18 ft 7 3/4 in"
> 
> construction_fraction(check1, type = "traditional", result =
+ "traditional", fraction = 8)
[1] "18 ft 7 6/8 in"
> 
> construction_fraction(check1, type = "traditional", result =
+ "traditional", fraction = 32)
[1] "18 ft 7 25/32 in"
> 
> construction_fraction(check1, type = "traditional", result =
+ "traditional", fraction = 64)
[1] "18 ft 7 50/64 in"
> 
> construction_fraction(check1, type = "traditional", result =
+ "traditional", fraction = 100)
[1] "18 ft 7 79/100 in"
> 
> construction_fraction(check1, type = "traditional", result =
+ "traditional", fraction = 128)
[1] "18 ft 7 101/128 in"
> 
> 
> 
> 
> 
> # Example 2
> 
> library(iemisc)
> import::from(fpCompare, "%==%")
> 
> 
> x1 <- construction_fraction(1.203125, type = "traditional", result =
+ "traditional", fraction = 16)
> 
> x2 <- construction_fraction(14.4375, type = "librecad", result =
+ "inch", fraction = 16)
> 
> x3 <- construction_fraction(14.4375, type = "librecad", result =
+ "traditional", fraction = 16)
> 
> x4 <- construction_fraction(14.43112, type = "librecad", result =
+ "traditional", fraction = 16)
> 
> x5 <- construction_fraction(14.43112, type = "librecad", result =
+ "inch", fraction = 16)
> 
> 
> ex1 <- frac_to_numeric(x2)
> 
> ex2 <- construction_decimal(x1, result = "librecad", output = "vector")
> 
> ex3 <- construction_decimal(x3, result = "librecad", output = "vector")
> 
> ex4 <- construction_decimal(x4, result = "librecad", output = "vector")
> 
> ex5 <- frac_to_numeric(x5)
> 
> 
> # check if ex1, ex2, ex3, ex4, and ex5 are equivalent
> ex1 %==% ex2
[1] TRUE
> 
> ex1 %==% ex3
[1] TRUE
> 
> ex1 %==% ex4
[1] TRUE
> 
> ex1 %==% ex5
[1] TRUE
> 
> ex2 %==% ex3
[1] TRUE
> 
> ex2 %==% ex4
[1] TRUE
> 
> ex2 %==% ex5
[1] TRUE
> 
> ex3 %==% ex4
[1] TRUE
> 
> ex3 %==% ex5
[1] TRUE
> 
> ex4 %==% ex5
[1] TRUE
> 
> 
> 
> 
> # Example 3 (from the Inch Calculator Reference)
> 
> library(iemisc)
> 
> construction_fraction(2.695, type = "librecad", result = "traditional",
+ fraction = 16)
[1] "0 ft 2 11/16 in"
> 
> construction_fraction(2.695, type = "librecad", result = "inch",
+ fraction = 16)
[1] "2 11/16 in"
> 
> 
> 
> 
> # Example 4
> 
> library(iemisc)
> 
> construction_fraction(17.71354, type = "traditional", result = "traditional",
+ fraction = 16)
[1] "17 ft 8 9/16 in"
> 
> construction_fraction(17.71354, type = "traditional", result = "inch",
+ fraction = 16)
[1] "212 9/16 in"
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘imports’

> nameEx("cosd")
> ### * cosd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cosd
> ### Title: Cosine (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: cosd
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example from GNU Octave cosd
> 
> cosd(seq(0, 80, by = 10))
[1] 1.0000000 0.9848078 0.9396926 0.8660254 0.7660444 0.6427876 0.5000000
[8] 0.3420201 0.1736482
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("cotd")
> ### * cotd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cotd
> ### Title: Cotangent (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: cotd
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave cotd
> cotd (seq(0, 80, by = 10))
[1]       Inf 5.6712818 2.7474774 1.7320508 1.1917536 0.8390996 0.5773503
[8] 0.3639702 0.1763270
> 
> cotd (c(0, 180, 360))
[1] Inf Inf Inf
> 
> cotd (c(90, 270))
[1] 0 0
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("cscd")
> ### * cscd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cscd
> ### Title: Cosecant (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: cscd
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave cscd
> cscd (seq(0, 90, by = 10))
 [1]      Inf 5.758770 2.923804 2.000000 1.555724 1.305407 1.154701 1.064178
 [9] 1.015427 1.000000
> 
> cscd (c(0, 180, 360))
[1] Inf Inf Inf
> 
> cscd (c(90, 270))
[1]  1 -1
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("cv")
> ### * cv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cv
> ### Title: Coefficient of variation (CV)
> ### Aliases: cv
> 
> ### ** Examples
> 
> 
> # Example 2.60 from Miller (page 38)
> 
> library(iemisc)
> 
> x <- c(14, 12, 21, 28, 30, 63, 29, 63, 55, 19, 20)
> # suspended solids in parts per million (ppm)
> 
> cv(x)
[1] 59.26511
> 
> 
> # using a matrix of the numeric vector x
> mat1 <- matrix(data = x, nrow = length(x), ncol = 1, byrow = FALSE,
+         dimnames = list(c(rep("", length(x))), "Samples"))
> cv(mat1)
 Samples 
59.26511 
> 
> 
> # using a data.frame of the numeric vector x
> df <- data.frame(x)
> cv(df)
       x 
59.26511 
> 
> 
> # using a data.table of the numeric vector x
> 
> library("data.table")
> 
> dt <- data.table(x)
> cv(dt)
       x 
59.26511 
> 
> 
> 
> # modified Example 2.60 from Miller (page 38)
> xx <- c(14, 12, 21, 28, 30, 63, 29, 63, 55, 19, 20, NA)
> # suspended solids in parts per million (ppm)
> 
> cv(xx) # na.rm = FALSE is the default
[1] NA
> cv(xx, na.rm = TRUE)
[1] 59.26511
> 
> 
> 
> 
> 
> 
> 
> 
> # Example 4 - from the archived cvcqv README
> 
> xu <- c(0.2, 0.5, 1.1, 1.4, 1.8, 2.3, 2.5, 2.7, 3.5, 4.4, 4.6, 5.4,
+ 5.4, 5.7, 5.8, 5.9, 6.0, 6.6, 7.1, 7.9)
> 
> results2 <- cv(xu)
> results2
[1] 57.77352
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’

> nameEx("density_water")
> ### * density_water
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: density_water
> ### Title: Density of Saturated Liquid Water
> ### Aliases: density_water
> 
> ### ** Examples
> 
> # Example 1 (Compare to reference standard in Reference paper)
> 
> library(iemisc)
> 
> 273.16 # K
[1] 273.16
> 
> 373.1243 # K
[1] 373.1243
> 
> 647.096 # K
[1] 647.096
> 
> Temp <- c(273.16, 373.1243, 647.096)
> 
> round::round_r3(density_water(Temp, units = "Absolute"), d = 3)
[1] 999.789 958.365 322.000
> 
> 
> # Reference standard
> 
> 999.789 # kg/m^3
[1] 999.789
> 958.365 # kg/m^3
[1] 958.365
> 322 # kg/m^3
[1] 322
> 
> 
> 
> 
> 
> # Example 2 - Example from the hydraulics package
> 
> library(iemisc)
> 
> rho <- hydraulics::dens(T = 25, units = "SI"); rho
[1] 997.0751
> 
> rho2 <- density_water(Temp = 25, units = "SI"); rho2
[1] 996.9994
> 
> 
> 
> 
> 
> # Example 3 - compare with densityH2Ov from aiRthermo
> 
> install.load::load_package("iemisc", "units")
udunits database from /Users/emaurer/Documents/classes/R_package_dev/hydraulics/revdep/library.noindex/iemisc/units/share/udunits/udunits2.xml
> 
> Temp <- 180
> 
> # create a numeric vector with the units of degrees Celsius
> T_C <- set_units(Temp, "degree_C")
> T_C
180 [°C]
> 
> # create a numeric vector to convert from degrees Celsius to Kelvin
> T_K <- T_C
> T_K
180 [°C]
> 
> # create a numeric vector with the units of Kelvin
> units(T_K) <- make_units(K)
> 
> pre <- aiRthermo::saturation_pressure_H2O(drop_units(T_K))
> pre
[1] 975166.3
> 
> rho_h2o <- aiRthermo::densityH2Ov(pre, drop_units(T_K), consts =
+ aiRthermo::export_constants()); rho_h2o
[1] 4.662995
> 
> # Should not be the same as aiRthermo deals with water vapor rather than
> # saturated liquid water
> 
> density_water(Temp = drop_units(T_K), units = "Absolute")
[1] 887.002
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:units’

> nameEx("dyn_visc_water")
> ### * dyn_visc_water
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dyn_visc_water
> ### Title: Absolute or Dynamic Viscosity for Liquid Water
> ### Aliases: dyn_visc_water
> 
> ### ** Examples
> 
> # Example 1 (Compare to the tabulated values in the Reference paper)
> 
> install.load::load_package("iemisc", "data.table", "round")
> 
> Temp <- c(0, 0.01, 3.86, seq(5, 95, by = 5), 99.974, seq(100, 150, by = 5))
> 
> dynamic_viscosity <- data.table("Temperature (degrees C)" = Temp,
+ "mu (* 10 ^ 6, kg / m*s)" = round_r3(dyn_visc_water(Temp, units = "SI")
+ * 10^6, d = 1))
> dynamic_viscosity
    Temperature (degrees C) mu (* 10 ^ 6, kg / m*s)
 1:                   0.000                  1792.7
 2:                   0.010                  1792.1
 3:                   3.860                  1575.4
 4:                   5.000                  1519.2
 5:                  10.000                  1306.8
 6:                  15.000                  1138.3
 7:                  20.000                  1002.1
 8:                  25.000                   890.3
 9:                  30.000                   797.4
10:                  35.000                   719.2
11:                  40.000                   652.8
12:                  45.000                   595.8
13:                  50.000                   546.6
14:                  55.000                   503.8
15:                  60.000                   466.2
16:                  65.000                   433.2
17:                  70.000                   403.8
18:                  75.000                   377.7
19:                  80.000                   354.4
20:                  85.000                   333.4
21:                  90.000                   314.5
22:                  95.000                   297.4
23:                  99.974                   282.0
24:                 100.000                   281.9
25:                 105.000                   267.7
26:                 110.000                   254.8
27:                 115.000                   243.0
28:                 120.000                   232.2
29:                 125.000                   222.2
30:                 130.000                   213.0
31:                 135.000                   204.5
32:                 140.000                   196.6
33:                 145.000                   189.3
34:                 150.000                   182.5
    Temperature (degrees C) mu (* 10 ^ 6, kg / m*s)
> 
> 
> 
> 
> 
> # Example 2 - Example from the hydraulics package
> 
> library(iemisc)
> 
> mu <- hydraulics::dvisc(T = 55, units = "Eng"); mu
[1] 2.546444e-05
> 
> mu2 <- dyn_visc_water(Temp = 55, units = "Eng", Eng_units = "lbf*s/ft^2"); mu2
[1] 2.524261e-05
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:round’, ‘package:data.table’

> nameEx("engr_survey")
> ### * engr_survey
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: engr_survey
> ### Title: Conversion of Engineering Survey Measurements to Decimal Degrees
> ###   (KY and TN)
> ### Aliases: engr_survey
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Engineering Survey Examples vignette for
> # additional examples
> 
> # Test 1 against TGRN Manual (Reference 5)
> # using the 1983 (1995) DATUM
> # GPS 1 is the station name with these coordinates
> # latitude (North) = 36 22 6.43923
> # longitude (West) = 82 10 46.87679
> 
> library(iemisc)
> 
> Northing_test1 <- 232489.480 # provided in TGRN Manual
> Easting_test1 <- 942754.124 # provided in TGRN Manual
> 
> tgrn1 <- engr_survey(Northing_test1, Easting_test1, "meters", "TN", output =
+ "table", utm = 0)
Warning in CPL_crs_from_input(x) :
  GDAL Message 1: +init=epsg:XXXX syntax is deprecated. It might return a CRS with a non-EPSG compliant axis order.
> tgrn1
                                               Parameters
1:                          Degrees (Latitude, Longitude)
2:                  Degrees Minutes (Latitude, Longitude)
3:          Degrees Minutes Seconds (Latitude, Longitude)
4:             State Plane (X = East, Y = North) [meters]
5:     State Plane (X = East, Y = North) [US survey foot]
6: State Plane (X = East, Y = North) [international foot]
                                  Value
1:                  36.36846, -82.17969
2:            36 22.10732, -82 10.78127
3:       36 22 6.43922, -82 10 46.87677
4:  Tennessee 4100 942754.12, 232489.48
5: Tennessee 4100 3093019.16, 762759.24
6: Tennessee 4100 3093025.34, 762760.76
> 
> 
> 
> # Test 2 against TGRN Manual (Reference 5)
> # using the 1983 (1995) DATUM
> # GPS 60 is the station name with these coordinates
> # latitude (North) = 35 8 46.44496
> # longitude (West) = 89 54 24.04763
> 
> library(iemisc)
> 
> Northing_test2 <- 97296.815 # provided in TGRN Manual
> Easting_test2 <- 244089.427 # provided in TGRN Manual
> 
> tgrn2 <- engr_survey(Northing_test2, Easting_test2, "meters", "TN", output =
+ "table", utm = 0)
> tgrn2
                                               Parameters
1:                          Degrees (Latitude, Longitude)
2:                  Degrees Minutes (Latitude, Longitude)
3:          Degrees Minutes Seconds (Latitude, Longitude)
4:             State Plane (X = East, Y = North) [meters]
5:     State Plane (X = East, Y = North) [US survey foot]
6: State Plane (X = East, Y = North) [international foot]
                                   Value
1:                   35.14623, -89.90668
2:              35 8.77408, -89 54.40079
3:        35 8 46.44497, -89 54 24.04763
4:  Tennessee 4100 244089.427, 97296.815
5: Tennessee 4100 800816.728, 319214.634
6:  Tennessee 4100 800818.33, 319215.272
> 
> 
> 
> # Test 3 against the NGS Data sheet (Reference 7)
> # using the NAD 83(1993) DATUM
> # with these adjusted coordinates
> # latitude (North) = 37 24 17.73330
> # longitude (West) = 086 14 14.18027
> 
> library(iemisc)
> 
> # The following coordinates were computed from the latitude / longitude
> # using NAD 83(1993)
> Northing_test3 <- "1,119,041.443" # provided in NGS Data sheet
> Easting_test3 <- "1,456,861.006" # provided in NGS Data sheet
> 
> ky1 <- engr_survey(Northing_test3, Easting_test3, "meters", "KY", output =
+ "table", utm = 0)
> ky1
                                               Parameters
1:                          Degrees (Latitude, Longitude)
2:                  Degrees Minutes (Latitude, Longitude)
3:          Degrees Minutes Seconds (Latitude, Longitude)
4:             State Plane (X = East, Y = North) [meters]
5:     State Plane (X = East, Y = North) [US survey foot]
6: State Plane (X = East, Y = North) [international foot]
                                                  Value
1:                                  37.40493, -86.23727
2:                            37 24.29555, -86 14.23633
3:                      37 24 17.73330, -86 14 14.18026
4: Kentucky (Single Zone) 1600 1456861.006, 1119041.443
5: Kentucky (Single Zone) 1600 4779718.151, 3671388.468
6:   Kentucky (Single Zone) 1600 4779727.71, 3671395.81
> 
> 
> 
> # Test 4 against the NGS Data sheet (Reference 8)
> # using the NAD 83(2011) DATUM
> # with these no check coordinates
> # latitude (North) = 38 04 23.86331
> # longitude (West) = 084 32 04.55607
> 
> library(iemisc)
> 
> # The following coordinates were computed from the latitude / longitude
> # using NAD 83(2011)
> Northing_test4 <- "3,671,388.47" # provided in NGS Data sheet
> Easting_test4 <- "4,779,718.15" # provided in NGS Data sheet
> 
> ky2 <- engr_survey(Northing_test4, Easting_test4, "survey_ft", "KY", output =
+ "table", utm = 0)
> ky2
                                               Parameters
1:                          Degrees (Latitude, Longitude)
2:                  Degrees Minutes (Latitude, Longitude)
3:          Degrees Minutes Seconds (Latitude, Longitude)
4:             State Plane (X = East, Y = North) [meters]
5:     State Plane (X = East, Y = North) [US survey foot]
6: State Plane (X = East, Y = North) [international foot]
                                                Value
1:                                37.40493, -86.23727
2:                          37 24.29555, -86 14.23633
3:                    37 24 17.73333, -86 14 14.18026
4: Kentucky (Single Zone) 1600 1456861.01, 1119041.44
5: Kentucky (Single Zone) 1600 4779718.15, 3671388.47
6: Kentucky (Single Zone) 1600 4779727.71, 3671395.81
> 
> 
> 
> 
> # Example 1
> # Kentucky (KY) Northing and Easting in US Survey foot
> 
> library(iemisc)
> 
> Northing1 <- 3807594.80077
> 
> Easting1 <- 5625162.88913
> 
> dt1 <- engr_survey(Northing = Northing1, Easting = Easting1, units =
+ "survey_ft", location = "KY", output = "table", utm = 1)
> dt1
                                                Parameters
 1:                          Degrees (Latitude, Longitude)
 2:                  Degrees Minutes (Latitude, Longitude)
 3:          Degrees Minutes Seconds (Latitude, Longitude)
 4:             State Plane (X = East, Y = North) [meters]
 5:     State Plane (X = East, Y = North) [US survey foot]
 6: State Plane (X = East, Y = North) [international foot]
 7:                                               UTM Zone
 8:                     UTM (X = East, Y = North) [meters]
 9:                UTM (X = East, Y = North) [centimeters]
10:             UTM (X = East, Y = North) [US survey foot]
11:         UTM (X = East, Y = North) [international foot]
                                                       Value
 1:                                       37.7548, -83.31483
 2:                                37 45.28801, -83 18.88967
 3:                          37 45 17.28063, -83 18 53.38068
 4: Kentucky (Single Zone) 1600 1714553.07771, 1160557.21639
 5: Kentucky (Single Zone) 1600 5625162.88913, 3807594.80077
 6: Kentucky (Single Zone) 1600 5625174.13948, 3807602.41597
 7:                                                      17S
 8:                                 296075.4463 4181133.1872
 9:                             29607544.6271 418113318.7181
10:                                971374.1933 13717601.1316
11:                                971376.1361 13717628.5669
> 
> 
> 
> # Example 2
> # Kentucky (KY) Northing and Easting in meters
> 
> library(iemisc)
> 
> Northing2 <- 1170338.983
> 
> Easting2 <- 1624669.125
> 
> dt2 <- engr_survey(Northing2, Easting2, "meters", "KY", output = "basic",
+ utm = 0)
> dt2
           X        Y
1: -84.33311 37.85963
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("engr_survey2")
> ### * engr_survey2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: engr_survey2
> ### Title: Calculate the Distance between Engineering Survey Points
> ### Aliases: engr_survey2
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Engineering Survey Examples vignette for
> # additional examples
> 
> # Example 1
> 
> library(iemisc)
> 
> engr_survey2("395+75", "397+13", station_distance = 100, units1 = "foot",
+ units2 = "foot")
138 [ft]
> 
> 
> 
> # Example 2
> 
> library(iemisc)
> 
> station1 <- "333+03"
> station2 <- "332+94"
> 
> engr_survey2(station1, station2, units1 = "foot", units2 = "survey_mile")
0.001704542 [US_survey_mile]
> 
> 
> 
> # Example 3 from Lewis Reference document page 25
> 
> library(iemisc)
> 
> station3 <- "10+25.62"
> station4 <- "189+45.72"
> 
> engr_survey2(station3, station4, units1 = "foot", units2 = "mile")
3.393958 [international_mile]
> 
> 
> 
> # Example 4 from Georgia reference page 27 (document page 43)
> 
> library(iemisc)
> 
> engr_survey2("701+50.00", "409+69.00", station_distance = 100,
+ units1 = "survey_ft", units2 = "foot")
29181 [ft]
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("engr_survey3")
> ### * engr_survey3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: engr_survey3
> ### Title: Calculate the Distance between Engineering Survey Points (Length
> ###   or Number of Stations)
> ### Aliases: engr_survey3
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Engineering Survey Examples vignette for
> # additional examples
> 
> # Example 1
> 
> library(iemisc)
> 
> # "What the others said is correct. 1 station is equal to 100 feet. So when
> # asked how many stations are in (3.2mi x 5280ft/mi = ) 16,896 feet, you are being
> # asked how many 100 foot-segments are in 16,896 feet? The answer of course is
> # 16,896ft / 100ft/sta = 168.96 sta." Source: Reference 2
> 
> length1 <- "16,896" # feet
> 
> engr_survey3(length1, station_distance = 100, units = "foot", output = "numeric")
[1] 168.96
> engr_survey3(length1, station_distance = 100, units = "foot", output = "string")
[1] "168.96 stations"
> # the answer provides the number of stations
> 
> # Note: Both answers should be the same as 3.2 miles = 16,896 feet.
> 
> length2 <- 3.2 # mile
> 
> engr_survey3(length2, station_distance = 100, units = "mile", output = "numeric")
[1] 168.96
> engr_survey3(length2, station_distance = 100, units = "mile", output = "string")
[1] "168.96 stations"
> # the answer provides the number of stations
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("engr_survey4")
> ### * engr_survey4
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: engr_survey4
> ### Title: Calculate the Station Distance between Engineering Survey Points
> ### Aliases: engr_survey4
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Engineering Survey Examples vignette for
> # additional examples
>  
> library(iemisc)
> 
> # Example 1
> 
> # "Conversely, if you were asked at what station a manhole 555 ft upstream of
> # Sta 0+00 is, your answer would be 0.00 sta + 555 ft / 100 ft/sta = 5.55 sta =
> # Sta 5+55." Source: Reference 2
> 
> engr_survey4(555, "0+00", units = "foot")
[1] "Sta. 5+55"
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("engr_survey_batch")
> ### * engr_survey_batch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: engr_survey_batch
> ### Title: Conversion of Engineering Survey Measurements to Decimal Degrees
> ###   (KY and TN) - Batch
> ### Aliases: engr_survey_batch
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Engineering Survey Examples vignette for
> # additional examples
> 
> # Example 1
> 
> # Tennessee (TN) Northing and Easting in US Survey foot
> 
> library(iemisc)
> 
> Northing1 <- c("630817.6396", "502170.6065", "562,312.2349", "574,370.7178")
> 
> Easting1 <- c("2559599.9201", "1433851.6509", "1,843,018.4099", "1,854,896.0041")
> 
> dt1 <- engr_survey_batch(Northing1, Easting1, "survey_ft", "TN", output = "basic")
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("engr_survey_reverse")
> ### * engr_survey_reverse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: engr_survey_reverse
> ### Title: Conversion of Latitude/Longitude Coordinates to Engineering
> ###   Survey Measurements (KY and TN)
> ### Aliases: engr_survey_reverse
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Engineering Survey Examples vignette for
> # additional examples
> 
> # Test against TGRN Manual (Reference 5)
> # using the 1983 (1995) DATUM
> # GPS 60 is the station name with these coordinates
> # latitude (North) = 35 8 46.44496
> # longitude (West) = 89 54 24.04763
> 
> # Northing is 97296.815 # provided in TGRN Manual
> # Easting is 244089.427 # provided in TGRN Manual
> 
> library(iemisc)
> 
> latitude <- "35 8 46.44496"
> longitude <- "89 54 24.04763"
> 
> Northing_test2 <- 97296.815 # provided in TGRN Manual
> Easting_test2 <- 244089.427 # provided in TGRN Manual
> 
> tgrn2A <- engr_survey_reverse(latitude, longitude, "meters", "TN", output = "table",
+ utm = 0)
> tgrn2A
                                               Parameters
1:                          Degrees (Latitude, Longitude)
2:                  Degrees Minutes (Latitude, Longitude)
3:          Degrees Minutes Seconds (Latitude, Longitude)
4:             State Plane (X = East, Y = North) [meters]
5:     State Plane (X = East, Y = North) [US survey foot]
6: State Plane (X = East, Y = North) [international foot]
                                     Value
1:                     35.14623, -89.90668
2:                35 8.77408, -89 54.40079
3:          35 8 46.44495, -89 54 24.04762
4:  Tennessee 4100 244089.4271, 97296.8146
5: Tennessee 4100 800816.7287, 319214.6326
6: Tennessee 4100 800818.3303, 319215.2711
> 
> tgrn2B <- engr_survey(Northing_test2, Easting_test2, "meters", "TN", output = "table",
+ utm = 0)
> tgrn2B
                                               Parameters
1:                          Degrees (Latitude, Longitude)
2:                  Degrees Minutes (Latitude, Longitude)
3:          Degrees Minutes Seconds (Latitude, Longitude)
4:             State Plane (X = East, Y = North) [meters]
5:     State Plane (X = East, Y = North) [US survey foot]
6: State Plane (X = East, Y = North) [international foot]
                                   Value
1:                   35.14623, -89.90668
2:              35 8.77408, -89 54.40079
3:        35 8 46.44497, -89 54 24.04763
4:  Tennessee 4100 244089.427, 97296.815
5: Tennessee 4100 800816.728, 319214.634
6:  Tennessee 4100 800818.33, 319215.272
> 
> 
> 
> 
> # Example 1
> 
> # Tennessee
> 
> library(iemisc)
> 
> lat <- 35.8466965
> 
> long <- -88.9206794
> 
> dt1B <- engr_survey_reverse(lat, long, units = "survey_ft", location = "TN", output =
+ "basic", utm = 1)
> dt1B
$data_projected
Simple feature collection with 1 feature and 0 fields
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 1103032 ymin: 563787 xmax: 1103032 ymax: 563787
Projected CRS: +init=epsg:32136 +units=us-ft
                geometry
1 POINT (1103032 563787)

$utm
   id UTM Zone UTM X = East [US survey foot] UTM Y = North [US survey foot]
1:  1      16S                       1071353                       13020473
   Hemisphere
1:      North

> 
> 
> 
> 
> # Example 2
> 
> # Kentucky
> 
> library(iemisc)
> 
> lats <- "37'50'21.5988''N"
> longs <- "84'16'12.0720'W"
> 
> dt2A <- engr_survey_reverse(lats, longs, "foot", "KY", output = "basic", utm = 0)
> dt2A
Simple feature collection with 1 feature and 0 fields
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 5348607 ymin: 3832586 xmax: 5348607 ymax: 3832586
Projected CRS: +init=epsg:3088 +units=ft
                 geometry
1 POINT (5348607 3832586)
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("f1")
> ### * f1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: f1
> ### Title: Laminar Flow Equation
> ### Aliases: f1
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples
> 
> f1(200)
[1] 0.32
> 
> f1(1999)
[1] 0.03201601
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("floor_division")
> ### * floor_division
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: %//%
> ### Title: Floor Division (Python compatible)
> ### Aliases: %//%
> 
> ### ** Examples
> 
> 
> # Example 1 -- From the Python reference
> 
> library(iemisc)
> 
> 5.0 / 2
[1] 2.5
> # 2.5
> 
> 5.0 %//% 2
[1] 2
> # 2.0
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("frac_to_numeric")
> ### * frac_to_numeric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: frac_to_numeric
> ### Title: Fraction (or Mixed number) to a Decimal (Numeric Vector)
> ### Aliases: frac_to_numeric
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Construction Measurement Examples vignette for
> # additional examples
>  
> # Example 1 -- Reference 1
> 
> library(iemisc)
> 
> xx <- as.character(fractional::fractional(1:9 / 12))
> 
> try(frac_to_numeric(xx))
Error : The length of n is greater than 1. n should only be 1 numeric vector. Please try again.
> # Please note that there will be an error because this function is designed to
> # only process one fraction at a time.
> 
> lapply(xx, frac_to_numeric)
[[1]]
[1] 0.08333333

[[2]]
[1] 0.1666667

[[3]]
[1] 0.25

[[4]]
[1] 0.3333333

[[5]]
[1] 0.4166667

[[6]]
[1] 0.5

[[7]]
[1] 0.5833333

[[8]]
[1] 0.6666667

[[9]]
[1] 0.75

> # Please note that this is the correct way to work with several fractions at once.
> 
> 
> 
> 
> # Example 2
> 
> library(iemisc)
> 
> xi <- fracture::fracture((50:65) / 12)
> 
> try(frac_to_numeric(xi))
Error : The length of n is greater than 1. n should only be 1 numeric vector. Please try again.
> # Please note that there will be an error because this function is designed to
> # only process one fraction at a time.
> 
> lapply(xi, frac_to_numeric)
[[1]]
[1] 4.166667

[[2]]
[1] 4.25

[[3]]
[1] 4.333333

[[4]]
[1] 4.416667

[[5]]
[1] 4.5

[[6]]
[1] 4.583333

[[7]]
[1] 4.666667

[[8]]
[1] 4.75

[[9]]
[1] 4.833333

[[10]]
[1] 4.916667

[[11]]
[1] 5

[[12]]
[1] 5.083333

[[13]]
[1] 5.166667

[[14]]
[1] 5.25

[[15]]
[1] 5.333333

[[16]]
[1] 5.416667

> # Please note that this is the correct way to work with several fractions at once.
> 
> 
> 
> 
> # Example 3
> 
> library(iemisc)
> 
> xyy <- fracture::fracture((1:11) / 12)
> 
> try(frac_to_numeric(xyy))
Error : The length of n is greater than 1. n should only be 1 numeric vector. Please try again.
> # Please note that there will be an error because this function is designed to
> # only process one fraction at a time.
> 
> lapply(xyy, frac_to_numeric)
[[1]]
[1] 0.08333333

[[2]]
[1] 0.1666667

[[3]]
[1] 0.25

[[4]]
[1] 0.3333333

[[5]]
[1] 0.4166667

[[6]]
[1] 0.5

[[7]]
[1] 0.5833333

[[8]]
[1] 0.6666667

[[9]]
[1] 0.75

[[10]]
[1] 0.8333333

[[11]]
[1] 0.9166667

> # Please note that this is the correct way to work with several fractions at once.
> 
> 
> 
>  
> # Example 4
> 
> library(iemisc)
> 
> xft <- as.character(MASS::fractions((1:70) / 12))
> 
> try(frac_to_numeric(xft))
Error : The length of n is greater than 1. n should only be 1 numeric vector. Please try again.
> # Please note that there will be an error because this function is designed to
> # only process one fraction at a time.
> 
> lapply(xft, frac_to_numeric)
[[1]]
[1] 0.08333333

[[2]]
[1] 0.1666667

[[3]]
[1] 0.25

[[4]]
[1] 0.3333333

[[5]]
[1] 0.4166667

[[6]]
[1] 0.5

[[7]]
[1] 0.5833333

[[8]]
[1] 0.6666667

[[9]]
[1] 0.75

[[10]]
[1] 0.8333333

[[11]]
[1] 0.9166667

[[12]]
[1] 1

[[13]]
[1] 1.083333

[[14]]
[1] 1.166667

[[15]]
[1] 1.25

[[16]]
[1] 1.333333

[[17]]
[1] 1.416667

[[18]]
[1] 1.5

[[19]]
[1] 1.583333

[[20]]
[1] 1.666667

[[21]]
[1] 1.75

[[22]]
[1] 1.833333

[[23]]
[1] 1.916667

[[24]]
[1] 2

[[25]]
[1] 2.083333

[[26]]
[1] 2.166667

[[27]]
[1] 2.25

[[28]]
[1] 2.333333

[[29]]
[1] 2.416667

[[30]]
[1] 2.5

[[31]]
[1] 2.583333

[[32]]
[1] 2.666667

[[33]]
[1] 2.75

[[34]]
[1] 2.833333

[[35]]
[1] 2.916667

[[36]]
[1] 3

[[37]]
[1] 3.083333

[[38]]
[1] 3.166667

[[39]]
[1] 3.25

[[40]]
[1] 3.333333

[[41]]
[1] 3.416667

[[42]]
[1] 3.5

[[43]]
[1] 3.583333

[[44]]
[1] 3.666667

[[45]]
[1] 3.75

[[46]]
[1] 3.833333

[[47]]
[1] 3.916667

[[48]]
[1] 4

[[49]]
[1] 4.083333

[[50]]
[1] 4.166667

[[51]]
[1] 4.25

[[52]]
[1] 4.333333

[[53]]
[1] 4.416667

[[54]]
[1] 4.5

[[55]]
[1] 4.583333

[[56]]
[1] 4.666667

[[57]]
[1] 4.75

[[58]]
[1] 4.833333

[[59]]
[1] 4.916667

[[60]]
[1] 5

[[61]]
[1] 5.083333

[[62]]
[1] 5.166667

[[63]]
[1] 5.25

[[64]]
[1] 5.333333

[[65]]
[1] 5.416667

[[66]]
[1] 5.5

[[67]]
[1] 5.583333

[[68]]
[1] 5.666667

[[69]]
[1] 5.75

[[70]]
[1] 5.833333

> # Please note that this is the correct way to work with several fractions at once.
> 
> 
> 
>  
> # Example 5
> 
> library(iemisc)
> 
> pix <- "270/11"
> 
> pi1 <- "22/7" # Reference 3
> 
> pi2 <- "355/113" # Reference 3
> 
> frac_to_numeric(pix)
[1] 24.54545
> 
> frac_to_numeric(pi1)
[1] 3.142857
> 
> frac_to_numeric(pi2)
[1] 3.141593
> 
> 
> 
>  
> # Example 6
> 
> # If you have a construction measurement that includes a dimension in feet,
> # such as 49 ft 7 5/8 in, don't use the frac_to_numeric function, instead
> # use the construction_fraction function.
> 
> library(iemisc)
> 
> xxift <- "49 ft 7 5/8 in"
> 
> construction_decimal(xxift, result = "traditional", output = "vector")
[1] 49.63542
> 
> 
> 
> 
> # Example 7 -- Reference 2
> 
> truss_marks <- "19 3/16 inches"
> 
> frac_to_numeric(truss_marks)
[1] 19.1875
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("grapes-inorder-grapes")
> ### * grapes-inorder-grapes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: %inorder%
> ### Title: IN ORDER for Character and Numeric Vectors
> ### Aliases: %inorder%
> 
> ### ** Examples
> 
> 
> # Examples (from the Source)
> 
> LETTERS[1:26 %in% 4:1]
[1] "A" "B" "C" "D"
> 
> LETTERS[1:26 %inorder% 4:1]
[1] "D" "C" "B" "A"
> 
> 
> 
> LETTERS[1:26 %in% 3:-5]
[1] "A" "B" "C"
> 
> LETTERS[1:26 %inorder% 3:-5]
[1] "C" "B" "A"
> 
> 
> data.frame(letters, LETTERS)[1:5 %in% 3:-5, ] 
   letters LETTERS
1        a       A
2        b       B
3        c       C
6        f       F
7        g       G
8        h       H
11       k       K
12       l       L
13       m       M
16       p       P
17       q       Q
18       r       R
21       u       U
22       v       V
23       w       W
26       z       Z
> 
> data.frame(letters, LETTERS)[1:5 %inorder% 3:-5, ]
  letters LETTERS
3       c       C
2       b       B
1       a       A
> 
> 
> library(data.table)
> 
> data.table(letters, LETTERS)[1:5 %inorder% 3:-5, ] 
   letters LETTERS
1:       c       C
2:       b       B
3:       a       A
> 
> 
> library(tibble)
> 
> tibble(letters, LETTERS)[1:5 %inorder% 3:-5, ]
# A tibble: 3 × 2
  letters LETTERS
  <chr>   <chr>  
1 c       C      
2 b       B      
3 a       A      
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:tibble’, ‘package:data.table’

> nameEx("grapes-notchin-grapes")
> ### * grapes-notchin-grapes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: %notchin%
> ### Title: Not CHIN or IN for Character and Numeric Vectors
> ### Aliases: %notchin%
> 
> ### ** Examples
> 
> 
> # Examples
> 
> x <- c("apple", "banana", "cherry", NA)
> 
> "apple" %notchin% x
[1] FALSE
> 
> c("apple", "BANANA", "coconut", NA) %notchin% x
[1] FALSE  TRUE  TRUE FALSE
> 
> x
[1] "apple"  "banana" "cherry" NA      
> 
> 
> "a" %notchin% letters[5:20]
[1] TRUE
> letters[5:20] %notchin% "a"
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[16] TRUE
> 
> 
> "a" %notchin% LETTERS
[1] TRUE
> LETTERS %notchin% "a"
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> 
> 
> 1 %notchin% -12:20
[1] FALSE
> -12:20 %notchin% 1
 [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
[13]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
[25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("grapes-qsin-grapes")
> ### * grapes-qsin-grapes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: %qsin%
> ### Title: Quick Search
> ### Aliases: %qsin%
> 
> ### ** Examples
> 
> 
> # Examples
> 
> x <- c("apple", "banana", "cherry", NA)
> 
> "apple" %qsin% x
[1] TRUE
> 
> c("APPLE", "BANANA", "coconut", NA) %qsin% x
[1]  TRUE  TRUE FALSE FALSE
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("igivenICPn")
> ### * igivenICPn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: igivenICPn
> ### Title: Simple Interest rate given Interest Charged, Number of years,
> ###   and Principal value
> ### Aliases: igivenICPn
> 
> ### ** Examples
> 
> 
> # Example 1
> 
> library(iemisc)
> 
> igivenICPn(P = 500, IC = 1000, n = 10)
[1] 20
> 
> 
> 
> 
> # Example 2
> 
> library(iemisc)
> 
> igivenICPn(P = 500, IC = 1000, begin_event = "1 January 2020", end_event = "1 January 2030")
[1] 20
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("igivenPFn")
> ### * igivenPFn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: igivenPFn
> ### Title: Interest rate given Future value, Number of periods, and Present
> ###   value (Engineering Economics)
> ### Aliases: igivenPFn
> 
> ### ** Examples
> 
> 
> # Example for equation 4-6 from the Reference text (page 128)
> 
> library(iemisc)
> 
> igivenPFn(P = 500, F = 1000, n = 10)
[1] 7.18
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("iscolumn")
> ### * iscolumn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: iscolumn
> ### Title: Column Vector (GNU Octave/MATLAB compatible)
> ### Aliases: iscolumn
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples
> 
> xxx <- ramify::mat("1, 2"); xxx
     [,1] [,2]
[1,]    1    2
> 
> iscolumn(xxx)
[1] FALSE
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("isrow")
> ### * isrow
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isrow
> ### Title: Row Vector (GNU Octave/MATLAB compatible)
> ### Aliases: isrow
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples
> 
> xx <- ramify::mat("1, 2"); xx
     [,1] [,2]
[1,]    1    2
> 
> isrow(xx)
[1] TRUE
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("kin_visc_water")
> ### * kin_visc_water
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: kin_visc_water
> ### Title: Kinematic Viscosity for liquid Water
> ### Aliases: kin_visc_water
> 
> ### ** Examples
> 
> # Example 1
> 
> 
> 
> 
> 
> # Example 2 (from the Reference)
> 
> install.load::load_package("iemisc", "units")
udunits database from /Users/emaurer/Documents/classes/R_package_dev/hydraulics/revdep/library.noindex/iemisc/units/share/udunits/udunits2.xml
> 
> import::from(fpCompare, "%==%")
> 
> 
> # For water at 68 F (20 C), mu = 2.09 * 10 ^ -8 slug/ft/s and rho = 1.937 slug/ft^3
> 
> kin_visc_water(mu = 2.09 * 10 ^ -8, rho = 1.937, rho_units =
+ "slug/ft^3", mu_units = "slug/ft/s")
[1] 1.078988e-08
> 
> # convert the units
> 
> rho <- set_units(1.937, slug/ft^3)
> 
> mu <- set_units(2.09 * 10 ^ -8, slug/ft/s)
> 
> mu1 <- set_units(mu, kg/m/s)
> 
> rho1 <- set_units(rho, "kg/m^3")
> 
> kin_visc_water(mu = mu1, rho = rho1, rho_units = "kg/m^3", mu_units =
+ "Pa*s or kg/m/s")
[1] 1.002413e-09
> 
> mu2 <- set_units(mu, lbf*s/ft^2)
> 
> rho2 <- set_units(rho, lb/ft^3)
> 
> kin_visc_water(mu = mu2, rho = rho2, rho_units = "lbm/ft^3", mu_units =
+ "lbf*s/ft^2")
[1] 3.353598e-10
> 
> 
> # compare the results of part 1 and part 3 (they should be equivalent)
> 
> kin_visc_water(mu = 2.09 * 10 ^ -8, rho = 1.937, rho_units = "slug/ft^3",
+ mu_units = "slug/ft/s") %==% kin_visc_water(mu = mu2, rho = rho2, rho_units =
+ "lbm/ft^3", mu_units = "lbf*s/ft^2")
[1] TRUE
> 
> 
> 
> 
> 
> # Example 2 - Example from the hydraulics package
> 
> install.load::load_package("iemisc", "units")
> 
> import::from(fpCompare, "%==%")
> 
> 
> nu <- hydraulics::kvisc(T = 55, units = "Eng", ret_units = TRUE); nu
1.31753e-05 [ft^2/s]
> 
> nus <- hydraulics::dvisc(T = 55, units = "Eng", ret_units = TRUE) /
+ hydraulics::dens(T = 55, units = "Eng", ret_units = TRUE); nus
1.314186e-05 [ft*lbf*s/slug]
> 
> 
> # compare the results of nu and nus (they should be equivalent)
> 
> drop_units(nu) %==% drop_units(nus)
[1] FALSE
> 
> 
> nu2 <- dyn_visc_water(Temp = 55, units = "Eng", Eng_units = "lbf*s/ft^2") /
+ density_water(Temp = 55, units = "Eng", Eng_units = "slug/ft^3"); nu2
[1] 1.301787e-05
> 
> nus2 <- kin_visc_water(mu = dyn_visc_water(Temp = 55, units = "Eng", Eng_units =
+ "lbf*s/ft^2"), rho = density_water(Temp = 55, units = "Eng", Eng_units = "slug/ft^3"),
+ rho_units = "lbm/ft^3", mu_units = "lbf*s/ft^2"); nus2
[1] 1.301787e-05
> 
> # compare the results of nu2 and nus2 (they should be equivalent)
> 
> nu2 %==% nus2
[1] TRUE
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘imports’, ‘package:units’

> nameEx("lat_long2state")
> ### * lat_long2state
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lat_long2state
> ### Title: United States of America (USA) State Identification Using
> ###   Latitude/Longitude Coordinates
> ### Aliases: lat_long2state
> 
> ### ** Examples
> 
> 
> # Example 1
> 
> library(iemisc)
> 
> lat_long2state(latitude = c(36.3684553, 40), longitude = c(-82.1796880, -89))
[1] "Tennessee" "Illinois" 
> lat_long2state(latitude = "36.3684553", longitude = "-82.1796880")
[1] "Tennessee"
> 
> 
> 
> # Example 2
> 
> # Test the function using points in Wisconsin and Oregon (From Source 1)
> 
> library(iemisc)
> 
> x = c(-90, -120); y = c(44, 44)
> lat_long2state(latitude = y, longitude = x)
[1] "Wisconsin" "Oregon"   
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("lat_long2utm")
> ### * lat_long2utm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lat_long2utm
> ### Title: Conversion of Latitude/Longitude to UTM Coordinates
> ### Aliases: lat_long2utm
> 
> ### ** Examples
> 
> 
> # Example 1
> # Test location from TGRN Reference Manual with NCAT
> # using the 1983 (1995) DATUM
> # GPS 1 is the station name with these coordinates
> # latitude (North) = 36 22 6.43923
> # longitude (West) = 82 10 46.87679
> 
> install.load::load_package("iemisc", "sp")
> 
> lats <- as.numeric(char2dms("36d22'6.43923\"N"))
> lats
[1] 36.36846
> 
> longs <- as.numeric(char2dms("82d10'46.87679\"W"))
> longs
[1] -82.17969
> 
> latsc <- as.character(lats)
> latsc
[1] "36.3684553416667"
> 
> longsc <- as.character(longs)
> longsc
[1] "-82.1796879972222"
> 
> lat_long2utm(latsc, longsc, units = "m", output = "basic")
$zone
[1] "17S"

$utm_final
Simple feature collection with 1 feature and 1 field
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 394172.1 ymin: 4025463 xmax: 394172.1 ymax: 4025463
Projected CRS: +proj=utm +zone=17 +ellps=WGS84 +North +units=m
  id                 geometry
1  1 POINT (394172.1 4025463)

> 
> lat_long2utm(latsc, longsc, units = "m", output = "table")
   id UTM Zone UTM X = East [meters] UTM Y = North [meters] Hemisphere
1:  1      17S              394172.1                4025463      North
> 
> lat_long2utm(lats, longs, units = "m", output = "basic")
$zone
[1] "17S"

$utm_final
Simple feature collection with 1 feature and 1 field
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 394172.1 ymin: 4025463 xmax: 394172.1 ymax: 4025463
Projected CRS: +proj=utm +zone=17 +ellps=WGS84 +North +units=m
  id                 geometry
1  1 POINT (394172.1 4025463)

> 
> lat_long2utm(lats, longs, units = "m", output = "table")
   id UTM Zone UTM X = East [meters] UTM Y = North [meters] Hemisphere
1:  1      17S              394172.1                4025463      North
> 
> # From https://www.ngs.noaa.gov/NCAT/
> # Latitude: 36.3684553416667
> # Longitude: -82.1796879972222
> # UTM Northing (m): 4,025,462.877
> # UTM Easting (m): 394,172.067
> # USNG: 17SLA9417225462
> 
> 
> 
> # Example 2
> # Test against Grid [Reference: National Geospatial-Intelligence Agency Office of Geomatics]
> 
> library(iemisc)
> 
> lat_long2utm("80", "-179", units = "m", output = "basic") # = 1X
$zone
[1] "1X"

$utm_final
Simple feature collection with 1 feature and 1 field
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 461235.9 ymin: 8882252 xmax: 461235.9 ymax: 8882252
Projected CRS: +proj=utm +zone=1 +ellps=WGS84 +North +units=m
  id                 geometry
1  1 POINT (461235.9 8882252)

> 
> lat_long2utm("-80", "-179", units = "m", output = "basic") # = 1C
$zone
[1] "1C"

$utm_final
Simple feature collection with 1 feature and 1 field
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 461235.9 ymin: -8882252 xmax: 461235.9 ymax: -8882252
Projected CRS: +proj=utm +zone=1 +ellps=WGS84 +South +units=m
  id                  geometry
1  1 POINT (461235.9 -8882252)

> 
> 
> 
> # Example 3
> # Test with world cities
> 
> 
> 
> 
> # Example 4
> # Test with 2 Web sites
> 
> library(iemisc)
> 
> latlong1 <- lat_long2utm(6.32, 7.41, units = "m", output = "table")
> latlong1
   id UTM Zone UTM X = East [meters] UTM Y = North [meters] Hemisphere
1:  1      32N              324118.8                 698847      North
> 
> latlong2 <- lat_long2utm(44.47, 19.81, units = "m", output = "table")
> latlong2
   id UTM Zone UTM X = East [meters] UTM Y = North [meters] Hemisphere
1:  1      34T                405349                4924765      North
> 
> 
> 
> # Results from https://www.latlong.net/lat-long-utm.html
> # Latitude: 6.32
> # Longitude: 7.41
> # UTM Easting: 324118.76
> # UTM Northing: 698846.97
> # UTM Zone: 32N
> 
> # Latitude: 44.47
> # Longitude: 19.81
> # UTM Easting: 405349.04
> # UTM Northing: 4924765.48
> # UTM Zone: 34T
> 
> 
> # Results from https://www.ngs.noaa.gov/NCAT/
> # Latitude: 6.32
> # Longitude: 7.41
> # UTM Northing (m): 698,846.969
> # UTM Easting (m): 324,118.758
> # USNG: 32NLM2411898846
> 
> # Latitude: 44.47
> # Longitude: 19.81
> # UTM Northing (m): 4,924,765.484
> # UTM Easting (m): 405,349.043
> # USNG: 34TDQ0534924765
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:sp’

> nameEx("length_octave")
> ### * length_octave
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: length_octave
> ### Title: Length of R objects (GNU Octave/MATLAB compatible)
> ### Aliases: length_octave
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> import::from(matlab, ones)
> 
> # Example from pracma isempty
> 
> object1 <- matrix(0, 1, 0)
> 
> length_octave(object1)
[1] 0
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘imports’

> nameEx("maxmre")
> ### * maxmre
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: maxmre
> ### Title: Maximum Mean relative error (MAXRE)
> ### Aliases: maxmre
> 
> ### ** Examples
> 
> 
> # Example 1
> 
> library(iemisc)
> 
> obs <- 1:10 # observed
> pre <- 2:11 # predicted
> maxmre(pre, obs)
[1] 2.928968
> 
> 
> 
> 
> # Example 2
> 
> install.load::load_package("iemisc", "rando", "data.table")
> 
> set_n(100) # makes the example reproducible
> obs1 <- r_norm(.seed = 605) # observed
> pre1 <- r_norm(.seed = 364) # predicted
> 
> 
> # using the vectors pre1 and obs1
> maxmre(pre1, obs1)
[1] 11448
> 
> 
> # using a matrix of the numeric vectors pre1 and obs1
> mat1 <- matrix(data = c(obs1, pre1), nrow = length(pre1), ncol = 2,
+ byrow = FALSE, dimnames = list(c(rep("", length(pre1))),
+ c("Predicted", "Observed")))
> maxmre(mat1[, 2], mat1[, 1])
[1] 11448
> 
> # mat1[, 1] # observed values from column 1 of mat1
> # mat1[, 2] # predicted values from column 2 of mat1
> 
> 
> # using a data.frame of the numeric vectors pre1 and obs1
> df1 <- data.frame(obs1, pre1)
> maxmre(df1[, 2], df1[, 1])
[1] 11448
> 
> # df1[, 1] # observed values from column 1 of df1
> # df1[, 2] # predicted values from column 2 of df1
> 
> 
> 
> # using a data.table of the numeric vectors pre1 and obs1
> df2 <- data.table(obs1, pre1)
> maxmre(df2[, 2, with = FALSE][[1]], df2[, 1, with = FALSE][[1]])
[1] 11448
> 
> # df2[, 1, with = FALSE][[1]] # observed values from column 1 of df2
> # df2[, 2, with = FALSE][[1]] # predicted values from column 2 of df2
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’, ‘package:rando’

> nameEx("mortality_rate")
> ### * mortality_rate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mortality_rate
> ### Title: Mortality Rate
> ### Aliases: mortality_rate
> 
> ### ** Examples
> 
> 
> # Example from Reference 1
> 
> library(iemisc)
> 
> mortality_rate(369369, 331534662, 5)
[1] 111.4119
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("mortality_rate_pct")
> ### * mortality_rate_pct
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mortality_rate_pct
> ### Title: Mortality Rate Percent
> ### Aliases: mortality_rate_pct
> 
> ### ** Examples
> 
> 
> # Example from Reference 1
> 
> library(iemisc)
> 
> mr_2020 <- mortality_rate(369369, 331534662, 5)
> 
> mortality_rate_pct(mortality_rate(15, 331534662, 5), 5)
[1] 4.524414e-06
> 
> mortality_rate_pct(mr_2020, 5)
[1] 0.1114119
> 
> mortality_rate_pct(15, 5)
[1] 0.015
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("mre")
> ### * mre
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mre
> ### Title: Mean relative error (MRE)
> ### Aliases: mre
> 
> ### ** Examples
> 
> 
> # Example 1
> 
> library(iemisc)
> 
> obs <- 1:10 # observed
> pre <- 2:11 # predicted
> mre(pre, obs)
[1] 0.2928968
> 
> 
> 
> 
> # Example 2
> 
> install.load::load_package("iemisc", "rando")
> 
> set_n(100) # makes the example reproducible
> obs1 <- r_norm(.seed = 873) # observed
> pre1 <- r_norm(.seed = 281) # predicted
> 
> 
> # using the vectors pre1 and obs1
> mre(pre1, obs1)
[1] 4.94223
> 
> 
> # using a matrix of the numeric vectors pre1 and obs1
> mat1 <- matrix(data = c(obs1, pre1), nrow = length(pre1), ncol = 2,
+    byrow = FALSE, dimnames = list(c(rep("", length(pre1))),
+    c("Predicted", "Observed")))
> mre(mat1[, 2], mat1[, 1])
[1] 4.94223
> 
> # mat1[, 1] # observed values from column 1 of mat1
> # mat1[, 2] # predicted values from column 2 of mat1
> 
> 
> # using a data.frame of the numeric vectors pre1 and obs1
> df1 <- data.frame(obs1, pre1)
> mre(df1[, 2], df1[, 1])
[1] 4.94223
> 
> # df1[, 1] # observed values from column 1 of df1
> # df1[, 2] # predicted values from column 2 of df1
> 
> 
> library("data.table")
> 
> # using a data.table of the numeric vectors pre1 and obs1
> df2 <- data.table(obs1, pre1)
> mre(df2[, 2, with = FALSE][[1]], df2[, 1, with = FALSE][[1]])
[1] 4.94223
> 
> # df2[, 1, with = FALSE][[1]] # observed values from column 1 of df2
> # df2[, 2, with = FALSE][[1]] # predicted values from column 2 of df2
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’, ‘package:rando’

> nameEx("n")
> ### * n
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: n
> ### Title: Manning's n for natural channels
> ### Aliases: n
> 
> ### ** Examples
> 
> library(iemisc)
> 
> # Example from Table 4. from the USGS Reference text page 35
> n(nb = 0.025, n4 = 0.005, m = 1.00)
[1] 0.03
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("na.interp1")
> ### * na.interp1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: na.interp1
> ### Title: na.interp1
> ### Aliases: na.interp1
> 
> ### ** Examples
> 
> 
> # zoo time series example
> 
> install.load::load_package("iemisc", "data.table")
> 
> zoo1 <- structure(c(1.6, 1.7, 1.7, 1.7, 1.7, 1.7, 1.6, 1.7, 1.7, 1.7,
+ 1.7, 1.7, 2, 2.1, 2.1, NA, NA, 2.1, 2.1, NA, 2.3, NA, 2, 2.1), .Dim = c(12L,
+ 2L), .Dimnames = list(NULL, c("V1", "V2")), index = structure(c(1395242100,
+ 1395243000, 1395243900, 1395244800, 1395245700, 1395256500, 1395257400,
+ 1395258300, 1395259200, 1395260100, 1395261000, 1395261900), class =
+ c("POSIXct", "POSIXt"), tzone = "GMT"), class = "zoo")
> 
> zoo1 <- as.data.frame(zoo1) # to data.frame from zoo
> 
> zoo1[, "Time"] <- as.POSIXct(rownames(zoo1)) # create column named Time as a
> # POSIXct class
> 
> zoo1 <- setDT(zoo1) # create data.table out of data.frame
> 
> setcolorder(zoo1, c(3, 1, 2)) # set the column order as the 3rd column
> # followed by the 2nd and 1st columns
> 
> zoo1 <- setDF(zoo1) # return to data.frame
> 
> rowsinterps1 <- which(is.na(zoo1$V2 == TRUE))
> 
> # index of rows of zoo1 that have NA (to be interpolated)
> xi <- as.numeric(zoo1[which(is.na(zoo1$V2 == TRUE)), 1])
> 
> # the Date-Times for V2 to be interpolated in numeric format
> interps1 <- na.interp1(as.numeric(zoo1$Time), zoo1$V2, xi = xi,
+ na.rm = FALSE, maxgap = 1)
> 
> # the interpolated values where only gap sizes of 1 are filled
> zoo1[rowsinterps1, 3] <- interps1
> 
> # replace the NAs in V2 with the interpolated V2 values
> zoo1
                  Time  V1   V2
1  2014-03-19 15:15:00 1.6 2.00
2  2014-03-19 15:30:00 1.7 2.10
3  2014-03-19 15:45:00 1.7 2.10
4  2014-03-19 16:00:00 1.7   NA
5  2014-03-19 16:15:00 1.7   NA
6  2014-03-19 19:15:00 1.7 2.10
7  2014-03-19 19:30:00 1.6 2.10
8  2014-03-19 19:45:00 1.7 2.20
9  2014-03-19 20:00:00 1.7 2.30
10 2014-03-19 20:15:00 1.7 2.15
11 2014-03-19 20:30:00 1.7 2.00
12 2014-03-19 20:45:00 1.7 2.10
> 
> 
> 
> 
> 
> 
> # data frame time series example
> 
> library(iemisc)
> 
> df1 <- structure(list(Time = structure(c(1395242100, 1395243000, 1395243900,
+  1395244800, 1395245700, 1395256500, 1395257400, 1395258300, 1395259200,
+  1395260100, 1395261000, 1395261900), class = c("POSIXct", "POSIXt"),
+  tzone = "GMT"), V1 = c(1.6, 1.7, 1.7, 1.7, 1.7, 1.7, 1.6, 1.7, 1.7, 1.7,
+  1.7, 1.7), V2 = c(2, 2.1, 2.1, NA, NA, 2.1, 2.1, NA, 2.3, NA, 2, 2.1)),
+  .Names = c("Time", "V1", "V2"), row.names = c(NA, -12L),
+  class = "data.frame")
> 
> rowsinterps1 <- which(is.na(df1$V2 == TRUE))
> 
> # index of rows of df1 that have NA (to be interpolated)
> xi <- as.numeric(df1[which(is.na(df1$V2 == TRUE)), 1])
> 
> # the Date-Times for V2 to be interpolated in numeric format
> interps1 <- na.interp1(as.numeric(df1$Time), df1$V2, xi = xi,
+  na.rm = FALSE, maxgap = 1)
> 
> # the interpolated values where only gap sizes of 1 are filled
> df1[rowsinterps1, 3] <- interps1
> 
> # replace the NAs in V2 with the interpolated V2 values
> df1
                  Time  V1   V2
1  2014-03-19 15:15:00 1.6 2.00
2  2014-03-19 15:30:00 1.7 2.10
3  2014-03-19 15:45:00 1.7 2.10
4  2014-03-19 16:00:00 1.7   NA
5  2014-03-19 16:15:00 1.7   NA
6  2014-03-19 19:15:00 1.7 2.10
7  2014-03-19 19:30:00 1.6 2.10
8  2014-03-19 19:45:00 1.7 2.20
9  2014-03-19 20:00:00 1.7 2.30
10 2014-03-19 20:15:00 1.7 2.15
11 2014-03-19 20:30:00 1.7 2.00
12 2014-03-19 20:45:00 1.7 2.10
> 
> 
> 
> 
> 
> 
> # data.table time series example
> 
> install.load::load_package("iemisc", "data.table")
> 
> dt1 <- structure(list(Time = structure(c(1395242100, 1395243000, 1395243900,
+  1395244800, 1395245700, 1395256500, 1395257400, 1395258300, 1395259200,
+  1395260100, 1395261000, 1395261900), class = c("POSIXct", "POSIXt"),
+  tzone = "GMT"), V1 = c(1.6, 1.7, 1.7, 1.7, 1.7, 1.7, 1.6, 1.7, 1.7, 1.7,
+  1.7, 1.7), V2 = c(2, 2.1, 2.1, NA, NA, 2.1, 2.1, NA, 2.3, NA, 2, 2.1)),
+  .Names = c("Time", "V1", "V2"), row.names = c(NA, -12L), class =
+  c("data.table", "data.frame"), sorted = "Time")
> 
> rowsinterps2 <- which(is.na(dt1[, 3, with = FALSE] == TRUE))
> 
> # index of rows of x that have NA (to be interpolated)
> xi <- as.numeric(dt1[rowsinterps2, Time])
> 
> # the Date-Times for V2 to be interpolated in numeric format
> interps2 <- dt1[, na.interp1(as.numeric(Time), V2, xi = xi,
+  na.rm = FALSE, maxgap = 1)]
> 
> # the interpolated values where only gap sizes of 1 are filled
> dt1[rowsinterps2, `:=` (V2 = interps2)]
> 
> # replace the NAs in V2 with the interpolated V2 values
> dt1
                   Time  V1   V2
 1: 2014-03-19 15:15:00 1.6 2.00
 2: 2014-03-19 15:30:00 1.7 2.10
 3: 2014-03-19 15:45:00 1.7 2.10
 4: 2014-03-19 16:00:00 1.7   NA
 5: 2014-03-19 16:15:00 1.7   NA
 6: 2014-03-19 19:15:00 1.7 2.10
 7: 2014-03-19 19:30:00 1.6 2.10
 8: 2014-03-19 19:45:00 1.7 2.20
 9: 2014-03-19 20:00:00 1.7 2.30
10: 2014-03-19 20:15:00 1.7 2.15
11: 2014-03-19 20:30:00 1.7 2.00
12: 2014-03-19 20:45:00 1.7 2.10
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’

> nameEx("nc1")
> ### * nc1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nc1
> ### Title: Horton method for composite Manning's n
> ### Aliases: nc1
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example from the Moore Reference text
> nc1(n = c(0.05, 0.035, 0.05, 0.04), P = c(22.22, 34.78, 2.00, 6.08))
[1] 0.04134724
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("nc2")
> ### * nc2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nc2
> ### Title: Einstein and Banks method for composite Manning's n
> ### Aliases: nc2
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example from the Moore Reference text
> nc2(n = c(0.05, 0.035, 0.05, 0.04), P = c(22.22, 34.78, 2.00, 6.08))
[1] 0.04164774
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("nc3")
> ### * nc3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nc3
> ### Title: Lotter method for composite Manning's n
> ### Aliases: nc3
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> nc3(n = c(0.0024, 0.035), P = c(23.65, 36.08), R = c(2.02, 6.23))
[1] 0.03756957
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("nc4")
> ### * nc4
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nc4
> ### Title: Krishnamurthy and Christensen method for composite Manning's n
> ### Aliases: nc4
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> nc4(n = c(0.0024, 0.035), P = c(23.65, 36.08), y = c(10.23, 7.38))
[1] 0.008760347
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("ndims")
> ### * ndims
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ndims
> ### Title: Number of dimensions in an Array (GNU Octave/MATLAB compatible)
> ### Aliases: ndims
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave ndims
> 
> b <- matlab::ones(c(4, 1, 2, 1))
> 
> ndims(b)
[1] 3
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("ngivenPFi")
> ### * ngivenPFi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ngivenPFi
> ### Title: To Find i Given F, n, and P (Engineering Economics)
> ### Aliases: ngivenPFi
> 
> ### ** Examples
> 
> 
> # Example for equation 4-7 from the Reference text (page 142)
> 
> library(iemisc)
> 
> ngivenPFi(P = 500, F = 1000, i = 15)
[1] 4.959484
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("numel")
> ### * numel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numel
> ### Title: Number of elements (GNU Octave/MATLAB compatible)
> ### Aliases: numel
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> import::from(matlab, ones)
> 
> xx <- list(1:26, 1:10)
> 
> numel(xx)
[1] 2
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘imports’

> nameEx("polygon_area")
> ### * polygon_area
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: polygon_area
> ### Title: Polygon Area (using the Shoelace Formula)
> ### Aliases: polygon_area
> 
> ### ** Examples
> 
> 
> # Example 1 from Source 2
> 
> library(iemisc)
> 
> x <- c(4,  4,  8,  8, -4, -4)
> y <- c(6, -4, -4, -8, -8, 6)
> 
> polygon_area(x, y, plot = 1)
[1] 128
> 
> # compare with pracma's and geometry's polyarea
> 
> pracma::polyarea(x, y)
[1] -128
> 
> geometry::polyarea(x, y)
[1] 128
> 
> 
> 
> 
> 
> # Example 2
> 
> library(iemisc)
> 
> type38 <- construction_decimal("46'-10 1/2\"", result = "traditional", output = "vector")
> 
> x38 <- c(0, 25, sum(25, type38, 10), sum(25, type38, 10, 25))
> 
> y38 <- c(0, rep((3 + 1 / 3), 2), 0)
> 
> polygon_area(x38, y38, plot = 1, fill = "darkseagreen3", color = "aquamarine4")
[1] 272.9167
> 
> # compare with pracma's and geometry's polyarea
> 
> pracma::polyarea(x38, y38)
[1] -272.9167
> 
> geometry::polyarea(x38, y38)
[1] 272.9167
> 
> 
> 
> 
> 
> # Example 3
> 
> install.load::load_package("iemisc", "data.table")
> 
> coords <- fread("
+ X,   Y
+ 0,	0
+ 34,	4
+ 58,	4
+ 84,	6.7
+ 184,	0", header = TRUE)
> 
> polygon_area(coords$X, coords$Y, plot = 1, color = "#00abff", fill = NA)
[1] 638.1
> # "Use NA for a completely transparent colour." (from ggplot2 color function)
> 
> # compare with pracma's and geometry's polyarea
> 
> pracma::polyarea(coords$X, coords$Y)
[1] -638.1
> 
> geometry::polyarea(coords$X, coords$Y)
[1] 638.1
> 
> 
> 
> 
> 
> # Example 4 from pracma
> 
> library(iemisc)
> 
> Xx <- c(0, 4, 4, 0)
> 
> Yy <- c(0, 0, 4, 4)
> 
> polygon_area(Xx, Yy, 1, color = "goldenrod1", fill = "#00abff")
[1] 16
> 
> # compare with pracma's and geometry's polyarea
> 
> pracma::polyarea(Xx, Yy)
[1] 16
> 
> geometry::polyarea(Xx, Yy)
[1] 16
> 
> 
> 
> 
> 
> # Example 5 from pracma
> 
> library(iemisc)
> 
> Xx1 <- c(0, 4, 2)
> 
> Yy1 <- c(0, 0, 4)
> 
> polygon_area(Xx1, Yy1, 1, color = "rosybrown", fill = "papayawhip")
[1] 8
> 
> # compare with pracma's and geometry's polyarea
> 
> pracma::polyarea(Xx1, Yy1)
[1] 8
> 
> geometry::polyarea(Xx1, Yy1)
[1] 8
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’

> nameEx("project_midpoint")
> ### * project_midpoint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: project_midpoint
> ### Title: Calculate the midpoint between two coordinates (KY and TN)
> ### Aliases: project_midpoint
> 
> ### ** Examples
> 
> 
> # Example 1
> 
> library(iemisc)
> 
> Northing_begin <- 283715.8495
> Easting_begin <- 1292428.3999
> 
> Northing_end <- 303340.6977
> Easting_end <- 1295973.7743
> 
> project_midpoint(Northing_begin, Easting_begin, Northing_end, Easting_end,
+ units = "survey_ft", location = "TN", output = "simple")
   Latitude Longitude
1:  35.1184  -88.2548
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("prop_mortality_ratio")
> ### * prop_mortality_ratio
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prop_mortality_ratio
> ### Title: Proportional Mortality Ratio
> ### Aliases: prop_mortality_ratio
> 
> ### ** Examples
> 
> 
> # Data from Reference 2 and Reference 3
> 
> library(iemisc)
> 
> prop_mortality_ratio(cause_deaths = 652486, total_deaths = 3458697)
[1] 18.86508
> # annual heart disease deaths & total deaths in the US in 2021
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("prop_solver")
> ### * prop_solver
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prop_solver
> ### Title: Proportion Solver
> ### Aliases: prop_solver
> 
> ### ** Examples
> 
> 
> # Example 1 from the Example # 1 from Reference 1
> 
> library(iemisc)
> 
> # 5 / x = 10 / 16
> 
> prop_solver(n1 = 5, n2 = 10, d2 = 16, output = "single")
[1] 8
> 
> 
> 
> 
> # Example 2
> 
> library(iemisc)
> 
> t1 <- "34 3 1/2"
> t2 <- 5
> t3 <- 5 / 2
> 
> t11 <- construction_decimal(t1, result = "traditional", output = "vector")
> 
> prop_solver(n1 = t11, n2 = 5, d1 = 5 / 2, output = "all")
[1] "34.2916666666667 / 2.5  =  5 / 0.364520048602673"
> 
> 
> 
> 
> # Example 3
> 
> library(iemisc)
> 
> # Refer to Reference 2 and Reference 3
> 
> # What is the numerator (n1) for the situation where VAERS reports 4,576 dead
> # people; however, the number of dead people is closer to 453,024 people?
> 
> d1 <- 100 / 100 # 100%
> n2 <- 4576 # number of deceased people
> d2 <- 453024 # number of deceased people
> 
> prop_solver(d1 = d1, n2 = n2, d2 = d2, output = "single")
[1] 0.01010101
> 
> 
> # What is the more accurate number of dead people (d2) where VAERS reports 4,576
> # dead people and we recognize that less than 1% of adverse reactions are reported
> # to VAERS?
> 
> n1 <- 0.99999999999999999999999999999999999999999999999 / 100 # less than 1%
> n11 <- 0.98 / 100 # less than 1%
> d1 <- 100 / 100 # number of deceased people
> n2 <- 4576 # number of deceased people
> 
> prop_solver(n1 = n1, d1 = d1, n2 = n2, output = "all")
[1] "0.01 / 1  =  4576 / 457600"
> 
> prop_solver(n1 = n1, d1 = d1, n2 = n2, output = "single")
[1] 457600
> 
> 
> prop_solver(n1 = n11, d1 = d1, n2 = n2, output = "all")
[1] "0.0098 / 1  =  4576 / 466938.775510204"
> 
> prop_solver(n1 = n11, d1 = d1, n2 = n2, output = "single")
[1] 466938.8
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("rain_garden_driveway")
> ### * rain_garden_driveway
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rain_garden_driveway
> ### Title: Rain Garden Sizing for Driveways
> ### Aliases: rain_garden_driveway
> 
> ### ** Examples
> 
> 
> # Note: the units must be consistent for the lengths and widths
> 
> # Example 1 (from the Reference)
> 
> library(iemisc)
> 
> dw_width1 <- c(15, 10)
> dw_length1 <- c(50, 25)
> lw_units <- "feet"
> rf_width1 <- 50
> rf_length1 <- 25
> rainfall_depth1 <- 1.5
> rainfall_depth_units <- "inch"
> rain_garden_depth <- 6
> rain_garden_depth_units <- "inch"
> 
> rain_garden_driveway(dw_length = dw_length1, dw_width = dw_width1, rf_length =
+ rf_length1, rf_width = rf_width1, lw_units = lw_units, rainfall_depth =
+ rainfall_depth1, rainfall_depth_units = rainfall_depth_units, rain_garden_depth
+ = rain_garden_depth, rain_garden_depth_units = rain_garden_depth_units)
   Driveway Drainage Area One-Quarter of Roof Area    Depth of Rain
1:           1000 sq. ft.            312.5 sq. ft. 0.125 ft of rain
   Design Storm Volume Rain Garden Depth Rain Garden Initial Size
1:            125 ft^3          0.5 feet              250 sq. ft.
   Rain Garden Initial Dimensions Total Drainage Area New Design Storm Volume
1:        10 ft wide x 25 ft long        1250 sq. ft.                156 ft^3
   Rain Garden Final Size Rain Garden Final Dimensions
1:            312 sq. ft.    10 ft wide x 31.2 ft long
> 
> 
> 
> # Example 2
> # from https://www.ecoccs.com/R_Examples/Simple-Rain-Garden-Sizing_with-R.html
> # Irucka Embry modified the Example from the Reference for this example
> 
> install.load::load_package("iemisc", "data.table")
> 
> dw_length2 <- c(construction_decimal("50 feet 3 1/2 inch", result <- "traditional",
+ output <- "vector"), construction_decimal("25 feet 5 7/8 inch", result <- "traditional",
+ output <- "vector"))
> dw_width2 <- c(construction_decimal("15 feet 10 3/4 inch", result <- "traditional",
+ output <- "vector"), construction_decimal("10 feet 7 3/8 inch", result <- "traditional",
+ output <- "vector"))
> lw_units <- "feet"
> rf_length2 <- construction_decimal("25 feet 10 1/4 inch", result <- "traditional",
+ output <- "vector")
> rf_width2 <- construction_decimal("12.5 feet 1 1/8 inch", result <- "traditional",
+ output <- "vector") * 4
> rainfall_depth2 <- 2.25
> rainfall_depth_units <- "inch"
> rain_garden_depth <- 6
> rain_garden_depth_units <- "inch"
> 
> driveway_table <- data.table(length = dw_length2, width = dw_width2)
> 
> roof_table <- data.table(length = rf_length2, width = rf_width2)
> 
> rain_garden_driveway(driveway_table = driveway_table, roof_table = roof_table,
+ lw_units = lw_units, rainfall_depth = rainfall_depth2, rainfall_depth_units =
+ rainfall_depth_units, rain_garden_depth = rain_garden_depth,
+ rain_garden_depth_units = rain_garden_depth_units)
   Driveway Drainage Area One-Quarter of Roof Area    Depth of Rain
1:           1070 sq. ft.            325.6 sq. ft. 0.188 ft of rain
   Design Storm Volume Rain Garden Depth Rain Garden Initial Size
1:            201 ft^3          0.5 feet              401 sq. ft.
   Rain Garden Initial Dimensions Total Drainage Area New Design Storm Volume
1:      10 ft wide x 40.1 ft long      1471.2 sq. ft.                276 ft^3
   Rain Garden Final Size Rain Garden Final Dimensions
1:            552 sq. ft.    10 ft wide x 55.2 ft long
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’

> nameEx("ranges")
> ### * ranges
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ranges
> ### Title: Sample range
> ### Aliases: ranges
> 
> ### ** Examples
> 
> 
> # Example 1
> 
> install.load::load_package("iemisc", "rando")
> 
> set_n(100) # makes the example reproducible
> 
> x <- r_norm(.seed = 943)
> 
> ranges(x)
[1] 4.889942
> 
> 
> install.load::load_package("iemisc", "rando")
> 
> set_n(100) # makes the example reproducible
> 
> (r.x <- ranges(r_norm(.seed = 100))); r.x
[1] 4.853884
[1] 4.853884
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:rando’

> nameEx("rational_formula")
> ### * rational_formula
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rational_formula
> ### Title: Modified Rational Method Equation
> ### Aliases: rational_formula
> 
> ### ** Examples
> 
> 
> # Example 1 from NRCS Reference
> 
> # Given
> # Urban setting with a drainage area of 12 acres
> # 6 acres = single family area
> # 3 acres = park
> # 3 acres = streets (concrete)
> # Soil = clay loam
> # Tc = 20 min (time of concentration)
> 
> # Find the instantaneous peak discharge for a 25-yr frequency flood at a
> # road crossing in an urban/rural area located in the Kansas City, Missouri
> # area.
> 
> 
> library(iemisc)
> 
> area1 <- c(6, 3, 3)
> C1 <- c(mean(c(0.30, 0.50)), 0.15, 0.90)
> C1_w <- weighted_C(C = C1, area = area1)
> 
> i1 <- 5.1 # in/hr
> 
> rational_formula(C_F = 25, C = C1_w, i = i1, A = sum(area1), area_units = "acre")
[1] 31.21494
> 
> 
> 
> 
> 
> 
> # Example 2 from NRCS Reference
> 
> # Given
> # Urban setting with a drainage area of 18 acres
> 
> # 1 ac = playground
> # 10 ac = single family area
> # 2 ac = streets (asphaltic)
> # 5 ac = pasture (hilly)
> # Soil = heavy clay
> # Tc = 20 min
> 
> # Find the instantaneous 100-yr frequency peak discharge for design of a
> # channel in a developing subdivision located in an area near Asheville,
> # North Carolina.
> 
> 
> library(iemisc)
> 
> area2 <- c(1, 10, 2, 5)
> C2 <- c(0.35, 0.50, 0.90, 0.60)
> C2_w <- weighted_C(C = C2, area = area2)
> 
> i2 <- 5.5 # in/hr
> 
> rational_formula(C_F = 100, C = C2_w, i = i2, A = sum(area2), area_units = "acre")
[1] 69.8544
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("reduce_single_digit")
> ### * reduce_single_digit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reduce_single_digit
> ### Title: Reduce an Integer, a Date (Time), or a Number (with or without
> ###   Decimals) to a Single Integer
> ### Aliases: reduce_single_digit
> 
> ### ** Examples
> 
> 
> # Please refer to the iemisc: Sound Frequencies & Nikola Tesla's 3-6-9 Theory
> # vignette
> # https://www.ecoccs.com/R_Examples/SoundFrequencies-and-3-6-9.pdf for
> # additional examples
> 
> 
> # Examples
> 
> library(iemisc)
> 
> reduce_single_digit(37)
[1] 1
> 
> reduce_single_digit(5094322.439344993211394)
[1] 7
> 
> reduce_single_digit(-438443.349435493)
[1] 7
> 
> reduce_single_digit("-48373744582.47362287482374")
[1] 3
> 
> reduce_single_digit("11-09-2022")
[1] 8
> 
> reduce_single_digit("24 December 1983 04:37:58.55543333")
[1] 3
> 
> reduce_single_digit("4 July 1776")
[1] 5
> 
> reduce_single_digit(9)
[1] 9
> 
> reduce_single_digit(0)
[1] 0
> 
> reduce_single_digit(94321155)
[1] 3
> 
> reduce_single_digit("011 (704) 904-0432")
[1] 8
> 
> reduce_single_digit("011-894-908-0945")
[1] 4
> 
> reduce_single_digit("908-0945")
[1] 8
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("relerror")
> ### * relerror
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: relerror
> ### Title: Relative error
> ### Aliases: relerror
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Example 4.1 from the Reference text (page 83)
> 
> relerror(1.648721, 1.5) # answer as a percent (%)
[1] 9.020386
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("righttri")
> ### * righttri
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: righttri
> ### Title: Right triangle calculations
> ### Aliases: righttri
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> righttri(a = 3, b = 4, c = 5)
$a
[1] 3

$b
[1] 4

$c
[1] 5

$Aangle
[1] 36.8699

$Bangle
[1] 53.1301

$Cangle
[1] 90

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("rms")
> ### * rms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rms
> ### Title: Root-mean-square
> ### Aliases: rms
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> samp <- c(0.5, 100, 1000.25, 345, 0.0213, 0, 45, 99, 23, 11, 1, 89, 0, 34,
+         65, 98, 3)
> 
> rms(samp)
[1] 261.7719
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("sat_vapor_pressure")
> ### * sat_vapor_pressure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sat_vapor_pressure
> ### Title: Saturation Vapor Pressure for Water
> ### Aliases: sat_vapor_pressure
> 
> ### ** Examples
> 
> 
> # Example 1 - Example from the hydraulics package
> 
> library(iemisc)
> 
> vps <- hydraulics::svp(T = 10, units = "SI"); vps
[1] 1228.188
> 
> vps2 <- sat_vapor_pressure(Temp = 10, units = "SI", formula = "Huang"); vps2
[1] 657.1132
> 
> 
> 
> 
> 
> # Example 2 - from the Huang Reference
> 
> library(iemisc)
> 
> sat_vapor_pressure(Temp = c(0.01, seq(from = 20, to = 100, by = 20)), units
+ = "SI", formula = "Huang")
[1] 657.1132
> 
> 
> 
> 
> 
> # Example 3 - compare with saturation_pressure_H2O from aiRthermo
> 
> install.load::load_package("iemisc", "units")
udunits database from /Users/emaurer/Documents/classes/R_package_dev/hydraulics/revdep/library.noindex/iemisc/units/share/udunits/udunits2.xml
> 
> Temp <- 40
> 
> # create a numeric vector with the units of degrees Celsius
> T_C <- set_units(Temp, "degree_C")
> T_C
40 [°C]
> 
> # create a numeric vector to convert from degrees Celsius to Kelvin
> T_K <- T_C
> T_K
40 [°C]
> 
> # create a numeric vector with the units of Kelvin
> units(T_K) <- make_units(K)
> 
> pre <- aiRthermo::saturation_pressure_H2O(drop_units(T_K))
> pre
[1] 7382.36
> 
> sat_vapor_pressure(Temp = drop_units(T_K), units = "Absolute", formula = "Huang")
[1] 7384.933
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:units’

> nameEx("sat_vapor_pressure_ice")
> ### * sat_vapor_pressure_ice
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sat_vapor_pressure_ice
> ### Title: Saturation Vapor Pressure for Ice
> ### Aliases: sat_vapor_pressure_ice
> 
> ### ** Examples
> 
> # Example from the Reference
> 
> library(iemisc)
> 
> sat_vapor_pressure_ice(Temp = seq(from = -100, to = 0, by = 20), units = "SI")
[1] 663.5903
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("sec")
> ### * sec
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sec
> ### Title: Secant (in radians)
> ### Aliases: sec
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples
> 
> sec (seq(-2, 2, by = 1) * pi)
[1]  1 -1  1 -1  1
> 
> sec ((3 * pi) / 4)
[1] -1.414214
> 
> sec (c((7/3) * pi, (5/2) * pi))
[1] 2.000000e+00 3.266248e+15
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("secd")
> ### * secd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: secd
> ### Title: Secant (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: secd
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave secd
> secd (seq(0, 80, by = 10))
[1] 1.000000 1.015427 1.064178 1.154701 1.305407 1.555724 2.000000 2.923804
[9] 5.758770
> 
> secd (c(0, 180, 360))
[1]  1 -1  1
> 
> secd (c(90, 270))
[1] Inf Inf
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("sgm")
> ### * sgm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sgm
> ### Title: Geometric mean
> ### Aliases: sgm
> 
> ### ** Examples
> 
> 
> # Example 1.13 from Kottegoda (page 13)
> 
> library(iemisc)
> 
> city_pop <- c(230000, 310000)
> sgm(city_pop)
[1] 267020.6
> 
> # Compare the geometric mean to the arithmetic mean
> mean(city_pop)
[1] 270000
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("shm")
> ### * shm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shm
> ### Title: Harmonic mean
> ### Aliases: shm
> 
> ### ** Examples
> 
> 
> # Example 1.12 from Kottegoda (page 13)
> 
> install.load::load_package("iemisc", "data.table")
> 
> x <- c(0.20, 0.24, 0.16) # stream velocities in m/s
> shm(x)
[1] 0.1945946
> 
> # using a matrix of the numeric vector x
> mat1 <- matrix(data = x, nrow = length(x), ncol = 1, byrow = FALSE,
+         dimnames = list(c(rep("", length(x))), "Velocities"))
> shm(mat1)
Velocities 
 0.1945946 
> 
> 
> # using a data.frame of the numeric vector x
> df1 <- data.frame(x)
> shm(df1)
        x 
0.1945946 
> 
> 
> # using a data.table of the numeric vector x
> df2 <- data.table(x)
> shm(df2)
        x 
0.1945946 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’

> nameEx("sind")
> ### * sind
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sind
> ### Title: Sine (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: sind
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave sind
> sind(seq(10, 90, by = 10))
[1] 0.1736482 0.3420201 0.5000000 0.6427876 0.7660444 0.8660254 0.9396926
[8] 0.9848078 1.0000000
> 
> sind(c(0, 180, 360))
[1] 0 0 0
> 
> sind(c(90, 270))
[1]  1 -1
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("size")
> ### * size
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: size
> ### Title: Size of R objects (GNU Octave/MATLAB compatible)
> ### Aliases: size
> 
> ### ** Examples
> 
> 
> # Example from GNU Octave ndims function reference
> 
> size(matlab::ones(4, 1, 2, 1))
[1] 4 1 2
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("sp_gravity")
> ### * sp_gravity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sp_gravity
> ### Title: Specific Volume
> ### Aliases: sp_gravity
> 
> ### ** Examples
> 
> # Examples
> 
> install.load::load_package("iemisc", "units")
udunits database from /Users/emaurer/Documents/classes/R_package_dev/hydraulics/revdep/library.noindex/iemisc/units/share/udunits/udunits2.xml
> 
> # The density of sand is 1500 kg/m^3 -- Reference 1
> 
> rho_sand <- set_units(1500, "kg/m^3")
> 
> 
> # convert this density to slug/ft^3
> rho_sand_slug <- rho_sand
> 
> # create a numeric vector with the units of slug/ft^3
> units(rho_sand_slug) <- make_units(slug/ft^3)
> 
> 
> # convert this density to lbm/ft^3
> rho_sand_lbm <- rho_sand
> 
> # create a numeric vector with the units of lb/ft^3
> units(rho_sand_lbm) <- make_units(lb/ft^3)
> 
> 
> 
> rho1 <- density_water(Temp = 68, units = "Eng", Eng_units = "slug/ft^3")
> 
> sp_gravity(rho_w = rho1, rho_s = rho_sand_slug, units = "Eng", Eng_units = "slug/ft^3")
[1] 1.502768
> 
> 
> rho2 <- density_water(Temp = 68, units = "Eng", Eng_units = "lbm/ft^3")
> 
> sp_gravity(rho_w = rho2, rho_s = rho_sand_lbm, units = "Eng", Eng_units = "lbm/ft^3")
[1] 1.502768
> 
> 
> rho3 <- density_water(Temp = 20, units = "SI")
> 
> sp_gravity(rho_w = rho3, rho_s = rho_sand, units = "SI")
[1] 1.502768
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:units’

> nameEx("sp_volume")
> ### * sp_volume
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sp_volume
> ### Title: Specific Volume
> ### Aliases: sp_volume
> 
> ### ** Examples
> 
> # Examples
> 
> library(iemisc)
> 
> rho1 <- density_water(Temp = 68, units = "Eng", Eng_units = "slug/ft^3")
> 
> sp_volume(rho = rho1) # slug/ft^3
[1] 0.5163298
> 
> 
> rho2 <- density_water(Temp = 68, units = "Eng", Eng_units = "lbm/ft^3")
> 
> sp_volume(rho = rho2) # lbm/ft^3
[1] 0.01604802
> 
> 
> rho3 <- density_water(Temp = 20, units = "SI")
> 
> sp_volume(rho = rho3) # kg / m^3
[1] 0.001001845
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("splitcomma")
> ### * splitcomma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: splitcomma
> ### Title: Split Comma
> ### Aliases: splitcomma
> 
> ### ** Examples
> 
> 
> # Example 1
> 
> install.load::load_package("iemisc", "data.table")
> 
> dtxx <- data.table(Names = c("Cooler, Wine", "Juice, Fruit", "Hard Water",
+ "Hot Bath", "Set, Data"))
> 
> dtxx[, Corrected_Names := splitcomma(dtxx$Names)]
> 
> dtxx
          Names Corrected_Names
1: Cooler, Wine     Wine Cooler
2: Juice, Fruit     Fruit Juice
3:   Hard Water      Hard Water
4:     Hot Bath        Hot Bath
5:    Set, Data        Data Set
> 
> 
> 
> # Example 2
> 
> xtrax <- "FALSER, BRATTIE & SIMX, AGONY"
> 
> splitcomma(xtrax)
[1] "BRATTIE FALSER" "AGONY SIMX"    
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’

> nameEx("splitremove")
> ### * splitremove
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: splitremove
> ### Title: Split Remove
> ### Aliases: splitremove
> 
> ### ** Examples
> 
> 
> # Example
> 
> install.load::load_package("iemisc", "data.table")
> 
> # create the list of items to remove from the text
> remove <- c("mister", "sir", "mr", "madam", "mrs", "miss", "ms", "iv",
+ "iii", "ii", "jr", "sr", "md", "phd", "mba", "pe", "mrcp", "and", "&", "prof",
+ "professor", "esquire", "esq", "dr", "doctor")
> 
> names <- data.table(Named = c("Alfredy 'Chipp' Kahner IV",
+ "Denis G. Barnekdt III", "JERUEG, RICHARDS Z. MR.", "EDWARDST, HOWARDD K. JR."))
> 
> # first use split comma
> names[, Corrected_Named := splitcomma(names$Named)]
> 
> names
                       Named           Corrected_Named
1: Alfredy 'Chipp' Kahner IV Alfredy 'Chipp' Kahner IV
2:     Denis G. Barnekdt III     Denis G. Barnekdt III
3:   JERUEG, RICHARDS Z. MR.    RICHARDS Z. MR. JERUEG
4:  EDWARDST, HOWARDD K. JR.   HOWARDD K. JR. EDWARDST
> 
> names[, Corrected_Named := splitremove(names$Corrected_Named, remove)]
> 
> names
                       Named        Corrected_Named
1: Alfredy 'Chipp' Kahner IV Alfredy 'Chipp' Kahner
2:     Denis G. Barnekdt III      Denis G. Barnekdt
3:   JERUEG, RICHARDS Z. MR.     RICHARDS Z. JERUEG
4:  EDWARDST, HOWARDD K. JR.    HOWARDD K. EDWARDST
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’

> nameEx("surf_tens_water")
> ### * surf_tens_water
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: surf_tens_water
> ### Title: Water Surface Tension for Liquid Water
> ### Aliases: surf_tens_water
> 
> ### ** Examples
> 
> # Example (Compare to the tabulated values in the Reference paper)
> 
> install.load::load_package("iemisc", "data.table", "round")
> 
> Temp <- c(0, 0.01, 3.86, seq(5, 95, by = 5), 99.974, seq(100, 150, by = 5))
> 
> surface_tension <- data.table("Temperature (degrees C)" = Temp, "omega (N / m)"
+ = round_r3(surf_tens_water(Temp, units = "SI"), d = 5)); surface_tension
    Temperature (degrees C) omega (N / m)
 1:                   0.000       0.07565
 2:                   0.010       0.07565
 3:                   3.860       0.07511
 4:                   5.000       0.07495
 5:                  10.000       0.07423
 6:                  15.000       0.07349
 7:                  20.000       0.07274
 8:                  25.000       0.07198
 9:                  30.000       0.07120
10:                  35.000       0.07041
11:                  40.000       0.06960
12:                  45.000       0.06878
13:                  50.000       0.06795
14:                  55.000       0.06710
15:                  60.000       0.06624
16:                  65.000       0.06537
17:                  70.000       0.06448
18:                  75.000       0.06358
19:                  80.000       0.06267
20:                  85.000       0.06175
21:                  90.000       0.06081
22:                  95.000       0.05987
23:                  99.974       0.05891
24:                 100.000       0.05891
25:                 105.000       0.05794
26:                 110.000       0.05696
27:                 115.000       0.05597
28:                 120.000       0.05496
29:                 125.000       0.05395
30:                 130.000       0.05293
31:                 135.000       0.05190
32:                 140.000       0.05085
33:                 145.000       0.04980
34:                 150.000       0.04874
    Temperature (degrees C) omega (N / m)
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:round’, ‘package:data.table’

> nameEx("surface_area")
> ### * surface_area
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: surface_area
> ### Title: Calculate the Total Surface Area of Linear Surfaces
> ### Aliases: surface_area
> 
> ### ** Examples
> 
> 
> # Note: the units must be consistent
> 
> # Example 1
> 
> library(iemisc)
> 
> length1 <- c(220, 150, 30)
> width1 <- c(75, 89, 80)
> surface_area(width = width1, length = length1, lw_units = "meter")
[1] 32250
> 
> 
> # Example 2
> 
> library(iemisc)
> 
> length2 <- c(333, 681, 73)
> width2 <- c(17.4, 9.5, 8)
> surface_area_table = list(Length = length2, Width = width2)
> surface_area(surface_area_table = surface_area_table, lw_units = "mile")
[1] 12847.7
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("tand")
> ### * tand
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tand
> ### Title: Tangent (in degrees) [GNU Octave/MATLAB compatible]
> ### Aliases: tand
> 
> ### ** Examples
> 
> 
> library(iemisc)
> 
> # Examples from GNU Octave tand
> tand(seq(10, 80, by = 10))
[1] 0.1763270 0.3639702 0.5773503 0.8390996 1.1917536 1.7320508 2.7474774
[8] 5.6712818
> 
> tand(c(0, 180, 360))
[1] 0 0 0
> 
> tand(c(90, 270))
[1] Inf Inf
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("uc_composite_CN")
> ### * uc_composite_CN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: uc_composite_CN
> ### Title: Composite CN (Curve Number) with Unconnected Impervious Area
> ### Aliases: uc_composite_CN
> 
> ### ** Examples
> 
> 
> # Please refer to iemiscdata: Weighted CN Calculations Using the Composite CN
> # vignette in the iemiscdata package
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("unit_wt")
> ### * unit_wt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: unit_wt
> ### Title: Unit Weight or Specific Weight
> ### Aliases: unit_wt
> 
> ### ** Examples
> 
> # Examples
> 
> library(iemisc)
> 
> rho1 <- density_water(Temp = 68, units = "Eng", Eng_units = "slug/ft^3")
> 
> unit_wt(rho = rho1, units = "Eng", Eng_units = "slug/ft^3")
[1] 62.31297
> 
> 
> rho2 <- density_water(Temp = 68, units = "Eng", Eng_units = "lbm/ft^3")
> 
> unit_wt(rho = rho2, units = "Eng", Eng_units = "lbm/ft^3")
[1] 62.31297
> 
> 
> rho3 <- density_water(Temp = 20, units = "SI")
> 
> unit_wt(rho = rho3, units = "SI")
[1] 9.788587
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("volsphere")
> ### * volsphere
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: volsphere
> ### Title: Sphere volume
> ### Aliases: volsphere
> 
> ### ** Examples
> 
> 
> install.load::load_package("iemisc", "data.table")
> 
> volsphere(3) # in
[1] 113.0973
> 
> volsphere(4.5) # in
[1] 381.7035
> 
> 
> x <- c(3, 4, 0.2, 12, 34, 7.5) # cm
> volsphere(x)
[1] 1.130973e+02 2.680826e+02 3.351032e-02 7.238229e+03 1.646362e+05
[6] 1.767146e+03
> 
> 
> # using a matrix of the numeric vector x
> mat1 <- matrix(data = x, nrow = length(x), ncol = 1, byrow = FALSE,
+        dimnames = list(c(rep("", length(x))), "Radius"))
> volsphere(mat1)
       Radius
 1.130973e+02
 2.680826e+02
 3.351032e-02
 7.238229e+03
 1.646362e+05
 1.767146e+03
> 
> 
> # using a data.frame of the numeric vector x
> df1 <- data.frame(x)
> volsphere(df1)
                x
[1,] 1.130973e+02
[2,] 2.680826e+02
[3,] 3.351032e-02
[4,] 7.238229e+03
[5,] 1.646362e+05
[6,] 1.767146e+03
> 
> 
> # using a data.table of the numeric vector x
> df2 <- data.table(x)
> volsphere(df2)
                x
[1,] 1.130973e+02
[2,] 2.680826e+02
[3,] 3.351032e-02
[4,] 7.238229e+03
[5,] 1.646362e+05
[6,] 1.767146e+03
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’

> nameEx("weighted_C")
> ### * weighted_C
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weighted_C
> ### Title: Calculate the Weighted C factor
> ### Aliases: weighted_C
> 
> ### ** Examples
> 
> 
> # Note: the default area unit is acre
> 
> # Example 1
> 
> library(iemisc)
> 
> area1 <- c(220, 150, 30)
> C1 <- c(75, 89, 80)
> weighted_C(C = C1, area = area1)
[1] 80.62
> 
> 
> # Example 2
> 
> library(iemisc)
> 
> area2 <- c(220, 150, 30)
> area_pct2 <- area2 / sum(area2)
> C2 <- c(80, 95, 80)
> C_area_pct_table2 <- data.frame(C2, area_pct2)
> weighted_C(C_area_pct_table = C_area_pct_table2)
[1] 85.62
> 
> 
> # Example 3
> 
> install.load::load_package("iemisc", "data.table")
> 
> C_area_table3 <- data.table(C = c(98, 100, 45), area = c(2.53, 453.00, 0.21))
> weighted_C(C_area_table = C_area_table3)
[1] 99.96
> 
> 
> # Example 4
> 
> library(iemisc)
> 
> C4 <- c(98, 100, 45)
> area_pct4 <- c(0.15, 0.23, 0.62)
> weighted_C(C = C4, area_pct = area_pct4)
[1] 65.6
> 
> 
> # Example 5
> 
> library(iemisc)
> 
> data_matrix5a <- matrix(c(98, 30, 40, 43, 57, 3.24, 1, 30, 50, 123), nrow = 5,
+ ncol = 2, dimnames = list(rep("", 5), c("C", "Area")))
> weighted_C(C_area_table = data_matrix5a)
[1] 51.67
> 
> 
> # using ramify to create the matrix
> 
> import::from(ramify, mat)
> 
> data_matrix5b <- mat("98 30 40 43 57;3.24 1 30 50 123", rows = FALSE, sep = " ",
+ dimnames = list(rep("", 5), c("C", "Area")))
> weighted_C(C_area_table = data_matrix5b)
[1] 51.67
> 
> 
> # Example 6 - using area in square feet
> 
> library(iemisc)
> 
> data_list6 <- list(C = c(77, 29, 68), Area = c(43560, 56893, 345329.32))
> weighted_C(C_area_table = data_list6, area_units = "square feet")
[1] 63.9
> 
> 
> # Example 7
> 
> install.load::load_package("iemisc", "data.table")
> 
> # Impervious area - 3.04 acre
> # 45% of total area
> # 0.80 C Factor
> 
> # Pervious area - 4.67 acre
> # 55% of total area
> # 0.20 C factor
> 
> C_area_table7 <- data.table(C = c(0.80, 0.20), area = c(3.04, 4.67))
> weighted_C(C_area_table = C_area_table7)
[1] 0.44
> 
> 
> # Example 8
> 
> # Impervious area - 2.44 acre
> # 32% of total area
> # 0.80 C Factor
> 
> # Pervious area - 5.03 acre
> # 68% of total area
> # 0.20 C factor
> 
> C8 <- c(0.80, 0.20)
> area_pct8 <- c(0.32, 0.68)
> weighted_C(C = C8, area_pct = area_pct8)
[1] 0.39
> 
> 
> # Example 9
> 
> library(iemisc)
> 
> # Medium density residential area - 30 hectares (75.0% of total area),
> # 0.31 - 0.40 C factor
> # High density residential area - 3 hectares (7.50% of total area),
> # 0.49 - 0.60 C factor
> # Agricultural area - 7 hectares (17.5% of total area), 0.15 - 0.21 C factor
> 
> C3 <- c(mean(seq(0.31, 0.40, by = 0.01)), mean(seq(0.49, 0.60, by = 0.01)),
+ mean(seq(0.15, 0.21, by = 0.01)))
> area3 <- c(30, 3, 7)
> weighted_C(C = C3, area = area3, area_units = "hectare")
[1] 0.34
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘imports’, ‘package:data.table’

> nameEx("weighted_CN")
> ### * weighted_CN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: weighted_CN
> ### Title: Calculate the Weighted CN (Curve Number)
> ### Aliases: weighted_CN
> 
> ### ** Examples
> 
> 
> # Note: the default area unit is an acre
> 
> # Example 1
> 
> library(iemisc)
> 
> area1 <- c(220, 150, 30)
> CN1 <- c(75, 89, 80)
> weighted_CN(CN = CN1, area = area1)
[1] 80.62
> 
> 
> # Example 2
> 
> library(iemisc)
> 
> area2 <- c(220, 150, 30)
> area_pct2 <- area2 / sum(area2)
> CN2 <- c(80, 95, 80)
> CN_area_pct_table2 <- data.frame(CN2, area_pct2)
> weighted_CN(CN_area_pct_table = CN_area_pct_table2)
[1] 85.62
> 
> 
> # Example 3
> 
> install.load::load_package("iemisc", "data.table")
> 
> CN_area_table3 <- data.table(CN = c(98, 100, 45), area = c(2.53, 453.00, 0.21))
> weighted_CN(CN_area_table = CN_area_table3)
[1] 99.96
> 
> 
> # Example 4
> 
> library(iemisc)
> 
> CN4 <- c(98, 100, 45)
> area_pct4 <- c(0.15, 0.23, 0.62)
> weighted_CN(CN = CN4, area_pct = area_pct4)
[1] 65.6
> 
> 
> # Example 5
> 
> library(iemisc)
> 
> import::from(ramify, mat)
> 
> 
> data_matrix5a <- matrix(c(98, 30, 40, 43, 57, 3.24, 1, 30, 50, 123),
+ nrow = 5, ncol = 2, dimnames = list(rep("", 5), c("C", "Area")))
> weighted_CN(CN_area_table = data_matrix5a)
[1] 51.67
> 
> 
> # using ramify to create the matrix
> data_matrix5b <- mat("98 30 40 43 57;3.24 1 30 50 123", rows = FALSE,
+ sep = " ", dimnames = list(rep("", 5), c("CN", "Area")))
> weighted_CN(CN_area_table = data_matrix5b)
[1] 51.67
> 
> 
> # Example 6 - using area in square feet
> 
> library(iemisc)
> 
> data_list6 <- list(CN = c(77, 29, 68), Area = c(43560, 56893, 345329.32))
> weighted_CN(CN_area_table = data_list6, area_units = "square feet")
[1] 63.9
> 
> 
> # Example 7 - using area in whole percents
> 
> library(iemisc)
> 
> CN7 <- c(61, 74)
> area_pct7 <- c(30, 70)
> weighted_CN(CN = CN7, area_pct = area_pct7)
[1] 70.1
> 
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘imports’, ‘package:data.table’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  16.491 0.255 18.535 0.005 0.007 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
